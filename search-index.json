[
  {
    "title": "Build Pipeline",
    "url": "/architecture/build-pipeline",
    "description": "Understand how MarkStack processes markdown files, renders content, applies templates, and generates the final static site.",
    "content": "Build Pipeline The build pipeline is the core of MarkStack. It takes markdown files as input and produces a complete static website as output. This page explains each stage of the process in detail. Pipeline Stages The build process runs through seven distinct stages: Initialization : Clear output, copy static files URL Mapping : Scan content and build URL lookup table Content Processing : Parse and render each markdown file Navigation Generation : Build sidebar and breadcrumbs Template Application : Inject content into HTML template Special Pages : Generate homepage and 404 page Search Index : Create JSON index for client-side search Stage 1: Initialization // Clear dist directory if (fs. existsSync ( CONFIG . distDir )) { fs. rmSync ( CONFIG . distDir , { recursive : true }); } ensureDir ( CONFIG . distDir ); // Copy static files if (fs. existsSync ( CONFIG . staticDir )) { copyDir ( CONFIG . staticDir , CONFIG . distDir ); } The build always starts fresh. The dist/ folder is deleted and recreated, ensuring no stale files remain from previous builds. Static assets (CSS, JavaScript, images) are copied unchanged. Stage 2: URL Mapping Before processing content, MarkStack scans all markdown files to build a URL map. This map connects file paths to their final URLs. const urlMap = new Map (); function buildUrlMap ( ) { // Scan content directory recursively function scanDirectory ( dirPath, parentSlugPath = &x27;&x27; ) { const entries = fs. readdirSync (dirPath, { withFileTypes : true }); for ( const entry of entries) { if (entry. isDirectory ()) { // Read index.md to get folder title // Generate slug from title // Map directory path to URL // Recurse into subdirectory } else if (entry. name . endsWith ( &x27;.md&x27; )) { // Read frontmatter for page title // Generate slug from title // Map file path to URL } } } scanDirectory ( CONFIG . contentDir ); } URL Generation URLs are generated from page titles using the slugify() function: function slugify ( title ) { return title . toLowerCase () . replace ( /[^a-z0-9\\s-]/g , &x27;&x27; ) // Remove special characters . replace ( /\\s+/g , &x27;-&x27; ) // Spaces to hyphens . replace ( /-+/g , &x27;-&x27; ) // Multiple hyphens to single . replace ( /^-|-$/g , &x27;&x27; ); // Trim leading/trailing hyphens } Examples: â€œGetting Startedâ€ becomes getting-started â€œMarkdown Featuresâ€ becomes markdown-features â€œCI/CD Integrationâ€ becomes cicd-integration The URL map ensures internal links can resolve correctly and navigation URLs match page URLs. Stage 3: Content Processing Each markdown file goes through the processMarkdownFile() function: function processMarkdownFile ( filePath ) { // Read file content const content = fs. readFileSync (filePath, &x27;utf-8&x27; ); // Parse frontmatter and markdown body const { data : frontmatter, content : markdownContent } = matter (content); // Extract or derive title const title = getTitle (filePath, frontmatter); // Get URL from map const urlPath = getUrlPath (filePath); // Build navigation context const nav = buildNavigationTree (filePath, urlPath); // Render markdown to HTML const htmlContent = md. render (markdownContent); return { title, description : frontmatter. description || CONFIG . defaultDescription , content : htmlContent, urlPath, breadcrumbs : nav. breadcrumbs , sidebar : nav. sidebar , frontmatter }; } Markdown Rendering MarkStack uses markdown-it with several plugins: const md = require ( &x27;markdown-it&x27; )({ html : true , // Allow raw HTML in markdown linkify : true , // Auto-link URLs typographer : true // Smart quotes and dashes }); // Add anchor links to headings md. use ( require ( &x27;markdown-it-anchor&x27; ), { permalink : anchor. permalink . ariaHidden ({ placement : &x27;before&x27; , symbol : &x27;&x27; , class : &x27;heading-anchor&x27; }) }); // Add footnote support md. use ( require ( &x27;markdown-it-footnote&x27; )); // Add task list support md. use ( require ( &x27;markdown-it-task-lists&x27; )); Syntax Highlighting Code blocks are highlighted using highlight.js: highlight : function ( str, lang ) { if (lang && hljs. getLanguage (lang)) { try { return &x27;<pre class=\"hljs\" data-language=\"&x27; + lang + &x27;\"><code>&x27; + hljs. highlight (str, { language : lang }). value + &x27;</code></pre>&x27; ; } catch (err) { // Fall through to plain text } } return &x27;<pre class=\"hljs\"><code>&x27; + md. utils . escapeHtml (str) + &x27;</code></pre>&x27; ; } GitHub-Style Alerts A custom markdown-it plugin transforms blockquotes starting with alert markers: md. core . ruler . after ( &x27;block&x27; , &x27;github-alerts&x27; , function ( state ) { const tokens = state. tokens ; for ( let i = 0 ; i < tokens. length ; i++) { if (tokens[i]. type === &x27;blockquoteopen&x27; ) { // Find inline content // Check for [!NOTE], [!TIP], etc. // Add alert classes and icon // Remove marker from content } } }); Input: > [!WARNING] > This is a warning message. Output: < blockquote class = \"alert alert-warning\" > < span class = \"alert-title\" > < span class = \"alert-icon\" > <!-- SVG --> </ span > WARNING </ span > < p > This is a warning message. </ p > </ blockquote > Stage 4: Navigation Generation Navigation is built from the directory structure. Sidebar Tree The buildFullNavTree() function walks the content directory and creates a nested structure: function buildFullNavTree ( dirPath, currentUrlPath ) { const items = []; const entries = fs. readdirSync (dirPath, { withFileTypes : true }); // Separate folders and files const folders = []; const files = []; for ( const entry of entries) { if (entry. isDirectory ()) { // Get folder title from index.md // Build children recursively folders. push ({ type : &x27;folder&x27; , title : folderTitle, url : folderUrl, expanded : currentUrlPath. startsWith (folderUrl), children : buildFullNavTree (entryPath, currentUrlPath) }); } else if (entry. name . endsWith ( &x27;.md&x27; ) && entry. name !== &x27;index.md&x27; ) { files. push ({ type : &x27;file&x27; , title : pageTitle, url : fileUrl, current : fileUrl === currentUrlPath }); } } // Sort alphabetically by title folders. sort ( ( a, b ) => a. title . localeCompare (b. title )); files. sort ( ( a, b ) => a. title . localeCompare (b. title )); return [...folders, ...files]; } Breadcrumbs Breadcrumbs are built by walking up from the current file to the root: function buildNavigationTree ( filePath, urlPath ) { const nav = { breadcrumbs : [], sidebar : buildFullNavTree ( CONFIG . contentDir , urlPath) }; // Start with Home nav. breadcrumbs . push ({ title : &x27;Home&x27; , url : &x27;/&x27; }); // Walk up directory tree const pathParts = relativePath. split ( &x27;/&x27; ). filter ( Boolean ); for ( const part of pathParts) { // Get directory or file title // Get URL from urlMap // Add to breadcrumbs } return nav; } Stage 5: Template Application The generatePage() function replaces placeholders in the template: function generatePage ( processed ) { const template = readTemplate ( &x27;base&x27; ); let html = template . replace ( /\\{\\{siteTitle\\}\\}/g , CONFIG . headerTitle ) . replace ( /\\{\\{title\\}\\}/g , processed. title ) . replace ( /\\{\\{description\\}\\}/g , processed. description ) . replace ( /\\{\\{url\\}\\}/g , CONFIG . siteUrl + processed. urlPath ) . replace ( /\\{\\{breadcrumbs\\}\\}/g , renderBreadcrumbs (processed. breadcrumbs )) . replace ( /\\{\\{sidebar\\}\\}/g , renderSidebar (processed. sidebar )) . replace ( /\\{\\{pageClass\\}\\}/g , processed. isHomepage ? &x27; is-homepage&x27; : &x27;&x27; ) . replace ( /\\{\\{copyrightText\\}\\}/g , CONFIG . copyrightText ) . replace ( /\\{\\{content\\}\\}/g , processed. content ); return html; } Sidebar HTML Rendering The sidebar tree is converted to HTML recursively: function renderSidebar ( sidebar, level = 0 ) { let html = &x27;<ul class=\"sidebar-list sidebar-level-&x27; + level + &x27;\">\\n&x27; ; for ( const item of sidebar) { const classes = [ &x27;sidebar-item&x27; , &x27;sidebar-&x27; + item. type ]; if (item. current ) classes. push ( &x27;sidebar-current&x27; ); if (item. expanded ) classes. push ( &x27;sidebar-expanded&x27; ); if (item. type === &x27;folder&x27; ) { html += &x27;<li class=\"&x27; + classes. join ( &x27; &x27; ) + &x27;\">&x27; ; html += &x27;<div class=\"sidebar-folder-header\">&x27; ; // Toggle button with chevron // Link with folder icon html += &x27;</div>&x27; ; html += &x27;<div class=\"sidebar-children\">&x27; ; html += renderSidebar (item. children , level + 1 ); html += &x27;</div>&x27; ; html += &x27;</li>&x27; ; } else { html += &x27;<li class=\"&x27; + classes. join ( &x27; &x27; ) + &x27;\">&x27; ; html += &x27;<a href=\"&x27; + item. url + &x27;\">&x27; + item. title + &x27;</a>&x27; ; html += &x27;</li>&x27; ; } } html += &x27;</ul>&x27; ; return html; } Stage 6: Special Pages Homepage The homepage is generated separately: function generateHomepage ( ) { let content = &x27;&x27; ; // Add hero section if enabled if ( CONFIG . showHero && ( CONFIG . siteTitle || CONFIG . siteSubtitle )) { content += &x27;<div class=\"homepage-hero\">&x27; ; // Add title and subtitle content += &x27;</div>&x27; ; } // Check for content/_index.md if (fs. existsSync (homepageIndexPath)) { // Render markdown content below hero } // Generate page with homepage flag const processed = { title : &x27;Home&x27; , content, urlPath : &x27;/&x27; , isHomepage : true // ... }; const html = generatePage (processed); fs. writeFileSync (path. join ( CONFIG . distDir , &x27;index.html&x27; ), html); } 404 Page The 404 page uses static content: function generate404 ( ) { const content = &x27;<div class=\"error-page\">...</div>&x27; ; const processed = { title : &x27;Page Not Found&x27; , content, urlPath : &x27;/404/&x27; , sidebar : [] }; const html = generatePage (processed); fs. writeFileSync (path. join ( CONFIG . distDir , &x27;404.html&x27; ), html); } Stage 7: Search Index The search index is built as pages are processed: const searchIndex = []; // During content processing: searchIndex. push ({ title : processed. title , url : processed. urlPath , description : processed. description , content : plainTextContent // HTML stripped }); // After all pages processed: function generateSearchIndex ( ) { fs. writeFileSync ( path. join ( CONFIG . distDir , &x27;search-index.json&x27; ), JSON . stringify (searchIndex, null , 2 ) ); } The content is stripped of HTML tags and markdown syntax to provide clean text for search: const plainContent = processed. content . replace ( /<[^>]>/g , &x27; &x27; ) // Remove HTML tags . replace ( /&quot;/g , &x27;\"&x27; ) // Decode entities . replace ( /{1,6}\\s/g , &x27;&x27; ) // Remove heading markers . replace ( /\\\\([^]+)\\\\*/g , &x27;$1&x27; ) // Remove bold . replace ( /\\[([^\\]]+)\\]\\([^)]+\\)/g , &x27;$1&x27; ) // Links to text . replace ( /\\s+/g , &x27; &x27; ) // Normalize whitespace . trim (); Output Structure The build produces: dist/ index.html Homepage 404.html Error page search-index.json Search data css/ main.css Copied from static/ hljs-theme.css js/ app.js Copied from static/ svg/ logo.svg Copied from static/ getting-started/ index.html Category page installation/ index.html Article page quickstart/ index.html authoring/ index.html ... Each page is output as [slug]/index.html for clean URLs. When a web server serves /getting-started/ , it serves /getting-started/index.html . Performance Considerations The build is optimized for speed: Single pass : Each file is read once In-memory processing : No intermediate files Direct I/O : No caching layers or virtual file systems Minimal dependencies : Only essential packages loaded For very large sites (500+ pages), consider: Using npm run build in CI rather than watch mode Ensuring adequate system memory for URL map"
  },
  {
    "title": "Navigation and Routing",
    "url": "/architecture/navigation-and-routing",
    "description": "Learn how MarkStack generates URLs from titles, builds navigation trees, creates breadcrumbs, and handles clean URL routing.",
    "content": "Navigation and Routing MarkStack automatically generates navigation from your content structure. This page explains how URLs are created, how the sidebar tree is built, and how routing works. URL Generation Title-Based URLs URLs are generated from page and folder titles, not filenames. This creates human-readable, SEO-friendly URLs. Title Generated URL Getting Started /getting-started/ Installation Guide /installation-guide/ Markdown Features /markdown-features/ CI/CD Integration /cicd-integration/ The Slugify Function The slugify() function converts titles to URL-safe slugs: function slugify ( title ) { return title . toLowerCase () // \"Getting Started\" â†’ \"getting started\" . replace ( /[^a-z0-9\\s-]/g , &x27;&x27; ) // Remove special chars . replace ( /\\s+/g , &x27;-&x27; ) // Spaces to hyphens . replace ( /-+/g , &x27;-&x27; ) // Multiple hyphens to single . replace ( /^-|-$/g , &x27;&x27; ); // Trim leading/trailing } Step-by-step example: Input: \"CI/CD Integration Guide!\" Step 1: \"ci/cd integration guide!\" Step 2: \"cicd integration guide\" Step 3: \"cicd-integration-guide\" Step 4: \"cicd-integration-guide\" Step 5: \"cicd-integration-guide\" Output: \"cicd-integration-guide\" Title Sources Titles come from these sources, in priority order: Frontmatter title : Explicitly set in the markdown file Filename : Derived from the filename if no frontmatter title Directory name : For index.md files, derived from parent directory --- title: My Custom Title This is used first --- If no frontmatter title exists: installation.md becomes â€œInstallationâ€ project-structure.md becomes â€œProject Structureâ€ CI-CD.md becomes â€œCI CDâ€ URL Map Before processing content, MarkStack builds a complete URL map: const urlMap = new Map (); // Maps file paths to URLs urlMap. set ( &x27;/content/authoring/markdown-features.md&x27; , &x27;/authoring/markdown-features/&x27; ); urlMap. set ( &x27;/content/getting-started/index.md&x27; , &x27;/getting-started/&x27; ); This map is consulted during content processing to: Generate correct navigation links Build accurate breadcrumbs Ensure internal consistency Directory Structure to URLs Basic Mapping File Path URL Path content/index.md / (homepage) content/about.md /about/ content/docs/index.md /docs/ content/docs/intro.md /docs/intro/ content/docs/guide/setup.md /docs/guide/setup/ Nested Categories Deep nesting works naturally: content/ platform/ index.md â†’ /platform/ aws/ index.md â†’ /platform/aws/ ec2.md â†’ /platform/aws/ec2/ s3.md â†’ /platform/aws/s3/ azure/ index.md â†’ /platform/azure/ vms.md â†’ /platform/azure/vms/ Each level adds to the URL path based on the directory or file title. Sidebar Navigation Tree Structure The sidebar is built as a tree structure that mirrors your content hierarchy: [ { type : &x27;folder&x27; , title : &x27;Getting Started&x27; , url : &x27;/getting-started/&x27; , expanded : true , // If current page is within children : [ { type : &x27;file&x27; , title : &x27;Installation&x27; , url : &x27;/getting-started/installation/&x27; , current : false }, { type : &x27;file&x27; , title : &x27;Quick Start&x27; , url : &x27;/getting-started/quickstart/&x27; , current : true // Current page } ] }, { type : &x27;folder&x27; , title : &x27;Authoring&x27; , url : &x27;/authoring/&x27; , expanded : false , children : [...] } ] Expansion State Folders expand automatically when: The current page is inside that folder The current page is inside a nested subfolder expanded : currentUrlPath. startsWith (folderUrl) If you are viewing /authoring/markdown-features/ , the Authoring folder expands, but other top-level folders remain collapsed. Sorting Items are sorted alphabetically by title within each level: folders. sort ( ( a, b ) => a. title . localeCompare (b. title )); files. sort ( ( a, b ) => a. title . localeCompare (b. title )); Folders appear before files at each level: ğŸ“ Architecture ğŸ“ Authoring ğŸ“ Getting Started ğŸ“„ About ğŸ“„ Changelog Rendering to HTML The tree is rendered recursively: < ul class = \"sidebar-list sidebar-level-0\" > < li class = \"sidebar-item sidebar-folder sidebar-expanded\" > < div class = \"sidebar-folder-header\" > < button class = \"sidebar-toggle\" > â–¼ </ button > < a href = \"/getting-started/\" > < svg > <!-- folder icon --> </ svg > Getting Started </ a > </ div > < div class = \"sidebar-children expanded\" > < ul class = \"sidebar-list sidebar-level-1\" > < li class = \"sidebar-item sidebar-file sidebar-current\" > < a href = \"/getting-started/quickstart/\" > < svg > <!-- file icon --> </ svg > Quick Start </ a > </ li > </ ul > </ div > </ li > </ ul > Client-Side Toggle Folder expand/collapse is handled by JavaScript: sidebarNav. addEventListener ( &x27;click&x27; , function ( e ) { const toggle = e. target . closest ( &x27;.sidebar-toggle&x27; ); if (!toggle) return ; e. preventDefault (); const sidebarItem = toggle. closest ( &x27;.sidebar-item&x27; ); const children = sidebarItem. querySelector ( &x27;.sidebar-children&x27; ); const isExpanded = sidebarItem. dataset . state === &x27;expanded&x27; ; if (isExpanded) { children. classList . remove ( &x27;expanded&x27; ); sidebarItem. dataset . state = &x27;collapsed&x27; ; toggle. innerHTML = chevronRight; // â†’ } else { children. classList . add ( &x27;expanded&x27; ); sidebarItem. dataset . state = &x27;expanded&x27; ; toggle. innerHTML = chevronDown; // â†“ } }); Breadcrumb Navigation Structure Breadcrumbs show the path from homepage to current page: Home / Getting Started / Quick Start Building Breadcrumbs Breadcrumbs are built by walking up the directory tree: function buildNavigationTree ( filePath, urlPath ) { const nav = { breadcrumbs : [], sidebar : ... }; // Always start with Home nav. breadcrumbs . push ({ title : &x27;Home&x27; , url : &x27;/&x27; }); // Walk each path segment const pathParts = relativePath. split ( &x27;/&x27; ). filter ( Boolean ); for ( const part of pathParts) { if (part === &x27;index.md&x27; ) continue ; // Skip index files if (part. endsWith ( &x27;.md&x27; )) { // It&x27;s a page - add with URL from map nav. breadcrumbs . push ({ title : pageTitle, url : urlMap. get (filePath) }); } else { // It&x27;s a directory - add with URL from map nav. breadcrumbs . push ({ title : directoryTitle, url : urlMap. get (directoryPath) }); } } return nav; } Rendering Breadcrumbs function renderBreadcrumbs ( breadcrumbs ) { return breadcrumbs. map ( ( item, i ) => { if (i === 0 ) { // Home link with icon return &x27;<a href=\"/\" class=\"breadcrumb-home\">&x27; + homeIcon + &x27;</a>&x27; ; } if (i === breadcrumbs. length - 1 ) { // Current page (not linked) return &x27;<span class=\"breadcrumb-current\">&x27; + item. title + &x27;</span>&x27; ; } // Intermediate links return &x27;<a href=\"&x27; + item. url + &x27;\">&x27; + item. title + &x27;</a>&x27; ; }). join ( &x27;<span class=\"breadcrumb-separator\">/</span>&x27; ); } Output: < a href = \"/\" class = \"breadcrumb-home\" > < svg > ... </ svg > </ a > < span class = \"breadcrumb-separator\" > / </ span > < a href = \"/getting-started/\" > Getting Started </ a > < span class = \"breadcrumb-separator\" > / </ span > < span class = \"breadcrumb-current\" > Quick Start </ span > Clean URLs Output Structure Each page is output as [slug]/index.html : dist/ getting-started/ index.html â† /getting-started/ installation/ index.html â† /getting-started/installation/ quickstart/ index.html â† /getting-started/quickstart/ How Clean URLs Work When a browser requests /getting-started/ , the web server: Looks for /getting-started/index.html Returns the index.html file Browser displays the URL without .html This is standard behavior for most web servers and hosting platforms. Server Configuration Most hosts handle this automatically. For self-hosted setups: nginx: location / { tryfiles $uri $uri / $uri /index.html = 404 ; } Apache (.htaccess): RewriteCond %{REQUESTFILENAME} !-f RewriteCond %{REQUESTFILENAME} /index.html -f RewriteRule ^(.*)$ $ 1 /index.html [L] Internal Link Resolution Linking Between Pages When writing markdown, use the URL path (not file path): See the installation guide . The URL is based on the page title, so: A page titled â€œInstallation Guideâ€ is at /installation-guide/ Not at /installation.md or /installation/ Relative Links Relative links also work: From /getting-started/installation/: Next: Quick Start However, absolute paths are clearer and less error-prone. Anchor Links Links to headings within pages use the slugified heading text: See the syntax section Heading anchors are generated by markdown-it-anchor: slugify : s => s. toLowerCase (). replace ( /[^\\w]+/g , &x27;-&x27; ) URL Consistency Why Title-Based URLs? Using titles for URLs instead of filenames provides: Readable URLs : /markdown-features/ vs /md-feat.md SEO benefits : Keywords in URL path Refactoring freedom : Rename files without breaking URLs (if title unchanged) Consistency : URLs match what users see in navigation Maintaining URL Stability If you change a page title, its URL changes. To maintain old URLs: Keep the original title in frontmatter Or set up redirects on your hosting platform --- title: Installation Guide Original title, keeps /installation-guide/ URL --- Setting Up MarkStack <!-- Display heading can differ --> Navigation Edge Cases Empty Directories Directories without index.md still appear in navigation, using the directory name as the title. Hidden Files Files and directories starting with . are ignored: content/ .drafts/ â† Ignored .hidden.md â† Ignored visible.md â† Processed Ordering Currently, items sort alphabetically. For custom ordering, prefix titles: --- title: 01 Introduction --- Or prefix filenames: 01-introduction.md 02-installation.md 03-configuration.md The URL will include the prefix, so consider if this is acceptable for your use case."
  },
  {
    "title": "Search Indexing",
    "url": "/architecture/search-indexing",
    "description": "Understand how MarkStack generates the search index and how the client-side search algorithm finds and ranks results.",
    "content": "Search Indexing MarkStack includes full-text search without requiring a server-side search engine. This page explains how the search index is generated and how search works in the browser. Search Architecture MarkStack search works entirely in the browser: Build time : Generate a JSON index with all page content Page load : Browser fetches the search index (on first search) Search time : JavaScript searches the index and displays results No server-side processing, no external search services, no API calls. Index Generation When the Index is Built The search index is generated as part of the build process. As each page is processed, its content is added to a global array: const searchIndex = []; // During content processing: searchIndex. push ({ title : processed. title , url : processed. urlPath , description : processed. description , content : plainTextContent }); After all pages are processed, the index is written: function generateSearchIndex ( ) { const outputPath = path. join ( CONFIG . distDir , &x27;search-index.json&x27; ); fs. writeFileSync (outputPath, JSON . stringify (searchIndex, null , 2 )); console . log ( &x27;âœ“ Generated: /search-index.json (&x27; + searchIndex. length + &x27; pages)&x27; ); } Index Entry Structure Each entry in the search index contains: { \"title\" : \"Markdown Features\" , \"url\" : \"/authoring/markdown-features/\" , \"description\" : \"Learn about all the markdown features supported by MarkStack.\" , \"content\" : \"MarkStack supports standard markdown syntax plus several extensions...\" } Field Source Purpose title Frontmatter or filename Display in results, high-weight matching url Generated URL path Link to the page description Frontmatter or default Display in results, medium-weight matching content Rendered markdown (stripped) Full-text search Content Cleaning The HTML content is stripped to plain text for indexing: const plainContent = processed. content // Remove HTML tags . replace ( /<[^>]>/g , &x27; &x27; ) // Decode HTML entities . replace ( /&quot;/g , &x27;\"&x27; ) . replace ( /&amp;/g , &x27;&&x27; ) . replace ( /</g , &x27;<&x27; ) . replace ( />/g , &x27;>&x27; ) . replace ( /'/g , \"&x27;\" ) . replace ( / /g , &x27; &x27; ) // Remove markdown syntax remnants . replace ( /{1,6}\\s/g , &x27;&x27; ) // Headings . replace ( /\\\\([^]+)\\\\/g , &x27;$1&x27; ) // Bold . replace ( /\\([^]+)\\/g , &x27;$1&x27; ) // Italic . replace ( /_([^]+)_/g , &x27;$1&x27; ) // Bold underscore . replace ( /([^]+)/g , &x27;$1&x27; ) // Italic underscore . replace ( /([^]+)`/g , &x27;$1&x27; ) // Inline code . replace ( /\\[([^\\]]+)\\]\\([^)]+\\)/g , &x27;$1&x27; ) // Links . replace ( /!\\[([^\\]])\\]\\([^)]+\\)/g , &x27;&x27; ) // Images . replace ( /^[\\s][-+]\\s+/gm , &x27;&x27; ) // List markers . replace ( /^[\\s]\\d+\\.\\s+/gm , &x27;&x27; ) // Numbered lists . replace ( /^>/gm , &x27;&x27; ) // Blockquotes // Normalize whitespace . replace ( /\\s+/g , &x27; &x27; ) . trim (); This ensures clean, searchable text without HTML noise or formatting artifacts. Client-Side Search Index Loading The search index is loaded lazily on first search: let searchIndex = null ; async function loadSearchIndex ( ) { if (searchIndex) return searchIndex; // Already loaded try { const response = await fetch ( &x27;/search-index.json&x27; ); searchIndex = await response. json (); return searchIndex; } catch (error) { console . error ( &x27;Failed to load search index:&x27; , error); return []; } } The index is cached in memory after loading. Subsequent searches use the cached data. Search Algorithm The search function performs simple substring matching with relevance scoring: function performSearch ( query, index ) { if (!query || query. length < 2 ) return []; const queryLower = query. toLowerCase (); const words = queryLower. split ( /\\s+/ ). filter ( w => w. length > 1 ); const results = []; for ( const item of index) { const titleLower = item. title . toLowerCase (); const contentLower = (item. content || &x27;&x27; ). toLowerCase (); const descriptionLower = (item. description || &x27;&x27; ). toLowerCase (); let score = 0 ; let matchContext = &x27;&x27; ; for ( const word of words) { // Title matches (highest weight) if (titleLower. includes (word)) { score += titleLower === word ? 100 : 50 ; } // URL matches if (item. url . toLowerCase (). includes (word)) { score += 30 ; } // Description matches if (descriptionLower. includes (word)) { score += 20 ; } // Content matches const contentIndex = contentLower. indexOf (word); if (contentIndex !== - 1 ) { score += 10 ; // Bonus for multiple occurrences const matches = (contentLower. match ( new RegExp (word, &x27;gi&x27; )) || []). length ; score += Math . min (matches, 10 ); // Extract context around match if (!matchContext) { const start = Math . max ( 0 , contentIndex - 60 ); const end = Math . min (item. content . length , contentIndex + word. length + 100 ); matchContext = item. content . substring (start, end); if (start > 0 ) matchContext = &x27;...&x27; + matchContext; if (end < item. content . length ) matchContext = matchContext + &x27;...&x27; ; } } } if (score > 0 ) { results. push ({ ...item, score, excerpt : matchContext || item. description || item. content . substring ( 0 , 150 ) + &x27;...&x27; }); } } return results . sort ( ( a, b ) => b. score - a. score ) . slice ( 0 , 10 ); } Scoring System Results are ranked by relevance score: Match Location Points Exact title match 100 Title contains word 50 URL contains word 30 Description contains word 20 Content contains word 10 Per additional content match +1 (max 10) Higher scores appear first in results. Multi-Word Queries For queries with multiple words, each word contributes to the score independently: Query: â€œmarkdown syntaxâ€ Page about â€œMarkdown Featuresâ€ with â€œsyntaxâ€ in content scores: 50 (title) + 10 (content) = 60 Page about â€œSyntax Highlightingâ€ with â€œmarkdownâ€ in content scores: 50 (title) + 10 (content) = 60 All words must match for a result to appear. Search Interface Dropdown Results As you type, results appear in a dropdown below the search input: searchInput. addEventListener ( &x27;input&x27; , async function ( e ) { const query = e. target . value . trim (); if (query. length < 2 ) { hideResults (); return ; } // Debounce to avoid excessive searches clearTimeout (searchTimeout); searchTimeout = setTimeout ( async function ( ) { const index = await loadSearchIndex (); const results = performSearch (query, index); renderResults (results, query); }, 150 ); }); Result Rendering Each result shows title, excerpt, and URL: function renderResults ( results, query ) { let html = &x27;&x27; ; for ( const item of results) { html += &x27;<a href=\"&x27; + item. url + &x27;\" class=\"search-result-item\">&x27; ; html += &x27;<div class=\"search-result-title\">&x27; + highlightMatch (item. title , query) + &x27;</div>&x27; ; html += &x27;<div class=\"search-result-excerpt\">&x27; + highlightMatch (item. excerpt , query) + &x27;</div>&x27; ; html += &x27;<div class=\"search-result-path\">&x27; + item. url + &x27;</div>&x27; ; html += &x27;</a>&x27; ; } searchResults. innerHTML = html; searchResults. classList . add ( &x27;active&x27; ); } Match Highlighting Matching terms are highlighted in results: function highlightMatch ( text, query ) { if (!text) return &x27;&x27; ; const words = query. toLowerCase (). split ( /\\s+/ ). filter ( w => w. length > 1 ); let result = escapeHtml (text); for ( const word of words) { const regex = new RegExp ( &x27;(&x27; + escapeRegex (word) + &x27;)&x27; , &x27;gi&x27; ); result = result. replace (regex, &x27;<mark>$1</mark>&x27; ); } return result; } Full Results Modal Pressing Enter opens a modal with all results: searchInput. addEventListener ( &x27;keydown&x27; , async function ( e ) { if (e. key === &x27;Enter&x27; ) { e. preventDefault (); const query = searchInput. value . trim (); if (query. length >= 2 ) { const index = await loadSearchIndex (); const results = performSearch (query, index); showFullSearchResults (query, results); } } }); Keyboard Navigation The search interface supports keyboard navigation: Key Action Ctrl+K Focus search input â†“ Move to first/next result â†‘ Move to previous result Enter Open selected result or show full results Escape Close search dropdown // Global shortcut document . addEventListener ( &x27;keydown&x27; , function ( e ) { if ((e. ctrlKey || e. metaKey ) && e. key === &x27;k&x27; ) { e. preventDefault (); searchInput. focus (); searchInput. select (); } }); // Navigate results searchResults. addEventListener ( &x27;keydown&x27; , function ( e ) { const current = document . activeElement ; if (e. key === &x27;ArrowDown&x27; ) { e. preventDefault (); const next = current. nextElementSibling ; if (next) next. focus (); } if (e. key === &x27;ArrowUp&x27; ) { e. preventDefault (); const prev = current. previousElementSibling ; if (prev) prev. focus (); else searchInput. focus (); } }); Index Size Considerations Typical Sizes The search index size depends on content volume: Pages Approximate Size 10 pages ~20 KB 50 pages ~100 KB 200 pages ~400 KB 500 pages ~1 MB Optimization Strategies For large sites, consider these optimizations: Gzip Compression Most servers compress JSON automatically. A 400 KB index compresses to approximately 100 KB. Truncate Content Modify the build script to limit content length: content : plainContent. substring ( 0 , 5000 ) // First 5000 chars only Exclude Pages Add frontmatter to exclude pages from search: --- title: Internal Notes searchable: false --- Then filter during index generation: if (frontmatter. searchable !== false ) { searchIndex. push ({...}); } Split Index For very large sites, split the index by section: /search-index-getting-started.json /search-index-authoring.json /search-index-reference.json Load only relevant indexes based on current page or user selection. Limitations No Fuzzy Matching The current search uses exact substring matching. â€œinstalâ€ will not match â€œinstallationâ€. Consider adding fuzzy matching for better UX: // Example with Fuse.js (would need to add as dependency) const fuse = new Fuse (index, { keys : [ &x27;title&x27; , &x27;description&x27; , &x27;content&x27; ], threshold : 0.4 }); No Stemming â€œrunningâ€ and â€œrunâ€ are treated as different words. For English content, a stemming algorithm would improve results. Client-Side Only Search happens entirely in the browser. For sites with thousands of pages, server-side search (Algolia, Elasticsearch) may be more appropriate. Extending Search Custom Scoring Modify the performSearch function to adjust scoring weights or add new criteria. Search Analytics Track what users search for: function performSearch ( query, index ) { // Track search if ( typeof gtag === &x27;function&x27; ) { gtag ( &x27;event&x27; , &x27;search&x27; , { search_term : query }); } // ... existing search logic } Filtering by Section Add section-based filtering: function performSearch ( query, index, section = null ) { let filteredIndex = index; if (section) { filteredIndex = index. filter ( item => item. url . startsWith ( &x27;/&x27; + section + &x27;/&x27; )); } // ... existing search logic on filteredIndex }"
  },
  {
    "title": "Architecture",
    "url": "/architecture/",
    "description": "Understand how MarkStack works internally, from the build pipeline to navigation generation, URL routing, and client-side search.",
    "content": "Architecture This section explains how MarkStack works under the hood. Understanding the architecture helps you extend the system, debug issues, and make informed decisions about customization. Design Philosophy MarkStack follows several design principles: Single-file build script : All build logic lives in build.js (approximately 800 lines). No framework overhead, no complex module structure. Zero runtime dependencies : The generated site is pure HTML, CSS, and JavaScript. No server-side processing required. Conventional structure : Directories map to URLs, filenames map to page titles. No configuration required for basic usage. Progressive enhancement : The site works without JavaScript, but interactive features (search, theme toggle) require it. System Overview MarkStack consists of three main components: Build Script (build.js) A Node.js script that transforms markdown content into a static website. It runs at build time, not runtime. HTML Template (templates/base.html) A single template file with placeholders that the build script populates for each page. Client-Side JavaScript (static/js/app.js) Handles interactive features in the browser: theme toggle, sidebar navigation, search, code copy buttons. High-Level Build Flow flowchart LR subgraph Input A[content/.md] B[static/] C[templates/*] end A --> D[build.js] B --> D C --> D D --> E[dist/] subgraph Output E --> F[index.html] E --> G[search-index.json] E --> H[css/] E --> I[js/] E --> J[\"[page-slug]/index.html\"] end Build script reads all markdown files from content/ Parses frontmatter and converts markdown to HTML Generates navigation structure (sidebar, breadcrumbs) Applies HTML template with placeholders Outputs static files to dist/ Creates search index for client-side search Copies static assets unchanged What This Section Covers Build Pipeline The Build Pipeline page explains: How files are discovered and processed Markdown rendering with plugins Template system and placeholder replacement Output file structure Navigation and Routing The Navigation and Routing page covers: URL generation from titles Sidebar tree construction Breadcrumb generation Clean URL handling Search Indexing The Search Indexing page details: Search index generation Client-side search algorithm Search result ranking Index optimization File Responsibilities File Responsibility build.js Complete static site generation templates/base.html Page structure and placeholders static/js/app.js Interactive browser features static/css/main.css All styling and theming static/css/hljs-theme.css Code syntax highlighting siteconfig.json Site-wide configuration values Dependencies MarkStack uses minimal dependencies: Package Purpose markdown-it Markdown parsing markdown-it-anchor Heading anchor links markdown-it-footnote Footnote syntax markdown-it-task-lists Checkbox task lists gray-matter YAML frontmatter parsing highlight.js Syntax highlighting chokidar File watching (dev mode only) No build tools like webpack, rollup, or bundlers. No CSS preprocessors. No framework dependencies. Extension Points When you need to extend MarkStack: New markdown features : Add markdown-it plugins in build.js New template placeholders : Modify generatePage() in build.js New client features : Add code to static/js/app.js New styles : Add CSS to static/css/main.css New alert types : Extend alertIcons object in build.js Performance Characteristics MarkStack builds are fast because: All processing happens in memory No external API calls during build No complex AST transformations Simple string-based template system Direct file I/O without caching layers Typical build times: 10 pages: ~50ms 50 pages: ~100ms 200 pages: ~300ms When to Read This Section Read the architecture documentation if you: Want to understand how MarkStack works Need to add custom features Are debugging build issues Plan to contribute to the project Want to fork and modify the system NOTE You do not need to understand the architecture to use MarkStack for documentation. This section is for those who want deeper knowledge or need to extend the system."
  },
  {
    "title": "Content Model",
    "url": "/authoring-content/content-model",
    "description": "Complete explanation of how MarkStack organizes documentation into categories and pages, generates URLs from titles, and builds navigation from your folder structure.",
    "content": "Content Model The content model defines how MarkStack transforms your markdown files into a structured documentation website. Understanding this model helps you organize content effectively and predict how changes will appear on your site. Core Concepts MarkStack uses a simple but powerful organizational model: Concept Definition Example Category A folder in content/ that groups related pages content/guides/ Page A markdown file that becomes a documentation page content/guides/setup.md Landing Page The index.md file that introduces a category content/guides/index.md Slug The URL-safe version of a title â€œGetting Startedâ€ becomes getting-started Categories Categories are folders inside the content/ directory. They serve two purposes: Organization : Group related documentation together Navigation : Appear as expandable sections in the sidebar Creating a Category To create a category, make a folder inside content/ and add an index.md file: content/ â””â”€â”€ guides/ â””â”€â”€ index.md The index.md file is the category landing page. It provides the category title and optional description: --- title: Guides description: Step-by-step tutorials for common tasks. --- Guides Welcome to the guides section. These tutorials walk you through common tasks from start to finish. When someone clicks the â€œGuidesâ€ section in the sidebar, they see this landing page. Category Behavior Without an index.md file, MarkStack still creates a category from the folder, but: The title comes from the folder name (with formatting applied) There is no landing page content The description uses the site default For example, a folder named getting-started/ without an index.md would appear in navigation as â€œGetting Startedâ€ but would have an empty landing page. TIP Always create an index.md for each category. It gives you control over the title and provides a place to introduce the section and guide readers to the right pages. Nested Categories Categories can nest to any depth. Each level needs its own index.md : content/ â””â”€â”€ api/ â”œâ”€â”€ index.md API landing page â”œâ”€â”€ authentication.md API > Authentication page â””â”€â”€ endpoints/ â”œâ”€â”€ index.md API > Endpoints landing page â”œâ”€â”€ users.md API > Endpoints > Users page â””â”€â”€ orders.md API > Endpoints > Orders page The sidebar shows this as an expandable tree. Breadcrumbs show the full path (Home / API / Endpoints / Users). Pages Pages are markdown files inside categories. Every .md file except index.md becomes a documentation page. Creating a Page Create a markdown file inside a category folder: content/ â””â”€â”€ guides/ â”œâ”€â”€ index.md â””â”€â”€ installation.md The page content follows the standard structure: --- title: Installation Guide description: How to install and configure the software. --- Installation Guide This guide walks through the installation process step by step. Prerequisites Before you begin, make sure you have: Operating system: Windows 10+, macOS 10.14+, or Ubuntu 18.04+ Disk space: At least 500 MB free Administrator access to your machine Step 1: Download Download the installer from our releases page... Page Titles Page titles come from two possible sources, in order of priority: Frontmatter title field (recommended) Filename (fallback) If you have a file named quick-start.md with this frontmatter: --- title: Quick Start Guide --- The page title is â€œQuick Start Guideâ€ (from frontmatter), not â€œQuick Startâ€ (from filename). If the same file had no frontmatter: Quick Start Content here... The title would be â€œQuick Startâ€ (derived from the filename quick-start.md ). IMPORTANT Always set the title in frontmatter. This gives you full control over the navigation label, page title, and URL generation. Page Descriptions The description frontmatter field serves multiple purposes: Appears in the HTML <meta name=\"description\"> tag for SEO Used in search result snippets Can appear in Open Graph tags for social sharing Write descriptions that: Summarize what the page covers in 150 to 160 characters Include relevant keywords naturally Help readers decide if this page answers their question URLs and Slugs MarkStack generates URLs from titles using a process called â€œslugification.â€ How Slugification Works The slugify function transforms titles into URL-safe strings: Convert to lowercase Replace spaces with hyphens Remove special characters (except hyphens) Collapse multiple hyphens into one Remove leading and trailing hyphens Original Title Resulting Slug Getting Started getting-started Installation Guide installation-guide API Reference api-reference Quick Start! quick-start The â€œBestâ€ Practices the-best-practices C++ Programming c-programming URL Structure URLs follow the category hierarchy with the page slug at the end: /category-slug/page-slug/ For nested categories: /category-slug/subcategory-slug/page-slug/ Complete URL Examples Given this content structure: content/ â”œâ”€â”€ index.md â†’ / â”œâ”€â”€ getting-started/ â”‚ â”œâ”€â”€ index.md (title: Getting Started) â†’ /getting-started/ â”‚ â”œâ”€â”€ installation.md (title: Installation) â†’ /installation/ â”‚ â””â”€â”€ quickstart.md (title: Quick Start) â†’ /quick-start/ â””â”€â”€ guides/ â”œâ”€â”€ index.md (title: Guides) â†’ /guides/ â””â”€â”€ advanced/ â”œâ”€â”€ index.md (title: Advanced Topics) â†’ /advanced-topics/ â””â”€â”€ performance.md (title: Performance Tuning) â†’ /performance-tuning/ Notice that URLs are based on the title slug, not the file path. The file getting-started/quickstart.md with title: Quick Start generates the URL /quick-start/ , not /getting-started/quickstart/ . URL Stability Because URLs derive from titles, changing a title changes the URL. This can break links from: Other pages in your documentation External websites Search engine results Bookmarks WARNING Changing a page title changes its URL. If the page has been published, add a redirect at your hosting provider to avoid broken links. Navigation MarkStack generates two navigation elements from your content structure: the sidebar and breadcrumbs. Sidebar The sidebar shows the complete content tree. It displays: All categories as expandable folders All pages as clickable links The current page highlighted Parent folders of the current page automatically expanded Sidebar items sort alphabetically by title at each level. A structure like: content/ â”œâ”€â”€ architecture/ â”‚ â””â”€â”€ index.md (title: Architecture) â”œâ”€â”€ authoring/ â”‚ â””â”€â”€ index.md (title: Authoring Content) â”œâ”€â”€ build-deploy/ â”‚ â””â”€â”€ index.md (title: Build & Deploy) â””â”€â”€ getting-started/ â””â”€â”€ index.md (title: Getting Started) Appears in the sidebar as: Architecture Authoring Content Build & Deploy Getting Started Controlling Sort Order If you need pages in a specific order, you have several options: Option 1: Number prefixes in titles --- title: 1 . Introduction --- This approach keeps numbers visible in navigation. Option 2: Descriptive names that sort naturally Choose titles that alphabetically sort in your desired order: â€œA. Overviewâ€ comes before â€œB. Configurationâ€ â€œFirst Stepsâ€ comes before â€œNext Stepsâ€ Option 3: Accept alphabetical order For many documentation sites, alphabetical order works fine. Readers can scan for the topic they need. Breadcrumbs Breadcrumbs show the path from the homepage to the current page. They help readers understand where they are in the documentation hierarchy and navigate upward. For a page at content/guides/advanced/performance.md : Home / Guides / Advanced Topics / Performance Tuning Each breadcrumb segment is clickable, linking to: Home: The homepage ( / ) Guides: The category landing page ( /guides/ ) Advanced Topics: The subcategory landing ( /advanced-topics/ ) Performance Tuning: The current page (not clickable) Practical Organization Tips Small Documentation Projects For projects with fewer than 20 pages, a flat structure works well: content/ â”œâ”€â”€ index.md â”œâ”€â”€ getting-started/ â”‚ â”œâ”€â”€ index.md â”‚ â”œâ”€â”€ installation.md â”‚ â””â”€â”€ configuration.md â”œâ”€â”€ usage/ â”‚ â”œâ”€â”€ index.md â”‚ â”œâ”€â”€ basic-usage.md â”‚ â””â”€â”€ advanced-usage.md â””â”€â”€ reference/ â”œâ”€â”€ index.md â””â”€â”€ api.md Large Documentation Projects For projects with many pages, use subcategories and clear naming: content/ â”œâ”€â”€ getting-started/ â”‚ â”œâ”€â”€ index.md â”‚ â””â”€â”€ ... (beginner content) â”œâ”€â”€ guides/ â”‚ â”œâ”€â”€ index.md â”‚ â”œâ”€â”€ tutorials/ â”‚ â”‚ â”œâ”€â”€ index.md â”‚ â”‚ â””â”€â”€ ... (tutorials) â”‚ â””â”€â”€ how-to/ â”‚ â”œâ”€â”€ index.md â”‚ â””â”€â”€ ... (how-to guides) â”œâ”€â”€ reference/ â”‚ â”œâ”€â”€ index.md â”‚ â”œâ”€â”€ api/ â”‚ â”‚ â”œâ”€â”€ index.md â”‚ â”‚ â””â”€â”€ ... (API docs) â”‚ â””â”€â”€ configuration/ â”‚ â”œâ”€â”€ index.md â”‚ â””â”€â”€ ... (config reference) â””â”€â”€ troubleshooting/ â”œâ”€â”€ index.md â””â”€â”€ ... (troubleshooting) Draft Content MarkStack does not have built-in draft support, but you can implement it with a simple pattern: Option 1: Separate folder Keep drafts outside content/ in a drafts/ folder. Move files to content/ when ready to publish. Option 2: Underscore prefix Name draft files with a leading underscore ( draft-page.md ). The build includes them, but you can use .gitignore to exclude them from version control until ready. Option 3: Separate branch Work on draft content in a Git branch. Merge to main when ready to publish. TIP For most projects, the separate folder approach is simplest. Keep drafts/ at the project root, work on content there, and move files to content/ when they are ready."
  },
  {
    "title": "Examples",
    "url": "/authoring-content/examples",
    "description": "Ready-to-use templates and examples for common MarkStack documentation patterns including category pages, documentation articles, and pages using multiple markdown features.",
    "content": "Examples This page provides templates for common documentation patterns. Use these as starting points when creating new content. Category Landing Pages Category landing pages are index.md files that introduce a documentation section. They set the category title, provide context, and help readers find the right content. Basic Category Landing Create a file at content/guides/index.md with this content: Frontmatter: --- title: Guides description: Step-by-step tutorials that walk you through common tasks from start to finish. --- Body content: Guides This section contains practical tutorials for getting things done. Each guide takes you through a complete workflow with explanations at every step. Available Guides Quick Start is the best place for newcomers Configuration covers all settings and options Advanced Topics for experienced users How to Use These Guides Work through guides in order if you are new, or jump to specific topics if you know what you need. Category Landing with Rich Content For categories that need substantial introductory content (like an API reference), structure your index.md with multiple sections: Frontmatter: --- title: API Reference description: Complete reference documentation for all API endpoints. --- Body with tables and notes: API Reference The API provides programmatic access to all platform features. Base URL All API requests use: https://api.yoursite.com/v1 Rate Limits | Plan | Requests/min | Requests/day | |------|--------------|--------------| | Free | 60 | 1,000 | | Pro | 600 | 50,000 | Endpoints Users for user management Projects for project operations Adding code examples: Use fenced code blocks with language hints for syntax highlighting: curl -H \"Authorization: Bearer YOURAPIKEY\" https://api.yoursite.com/v1/users Adding callouts: > [!NOTE] > The API uses JSON for all request and response bodies. Tutorial Pages Tutorials walk readers through a process step by step. Structure them with clear prerequisites, numbered steps, and troubleshooting. Tutorial Structure Frontmatter: --- title: Creating Your First Project description: Learn how to create, configure, and deploy your first project. --- Introduction with prerequisites: Creating Your First Project This tutorial walks you through creating a project from scratch. Prerequisites Before starting, make sure you have: An account with admin access The CLI tool installed (see Installation ) About 15 minutes of uninterrupted time Numbered steps with commands: Step 1: Initialize the Project Open your terminal and run the initialization command: Then add a code block: project init my-first-project cd my-first-project Show directory structures: my-first-project/ â”œâ”€â”€ config.yaml â”œâ”€â”€ src/ â”‚ â””â”€â”€ main.js â””â”€â”€ README.md Add helpful tips: > [!TIP] > Use project run --watch to automatically restart when files change. End with next steps: Next Steps Now that you have a running project: Add environment variables for configuration Set up a custom domain for production use Reference Pages Reference pages document configuration options, API parameters, or other technical details. Use tables for properties and code blocks for examples. Reference Structure Frontmatter: --- title: Configuration Options description: Complete reference for all configuration file settings. --- Option documentation pattern: For each configuration option, document it with a description, property table, and example: server.port The port the server listens on. | Property | Value | |----------|-------| | Type | integer | | Required | No | | Default | 3000 | | Range | 1-65535 | Then show an example: server: port: 8080 Complete example at the end: Complete Example Here is a complete configuration file with common settings: name: customer-portal version: 2.1 .0 environment: production server: port: 8080 host: 0.0 .0 .0 database: url: postgres://localhost/mydb poolsize: 10 Pages with Multiple Features Real documentation pages combine many markdown features. Hereâ€™s how they work together. Tables for Comparisons | Method | Best For | Complexity | |--------|----------|------------| | API Keys | Server-to-server | Low | | OAuth 2.0 | User-facing apps | Medium | | Sessions | Web applications | Medium | Task Lists for Checklists [x] API keys stored in environment variables [x] HTTPS enforced for all endpoints [ ] Rate limiting configured [ ] Key rotation schedule established Footnotes for References Rotate keys periodically to limit exposure if a key is compromised[^1]. [ ^1 ]: Industry best practice recommends rotating keys every 90 days. Alert Callouts Use different alert types for different purposes: > [!NOTE] > Informational content that adds context. > [!TIP] > Helpful suggestions that improve the experience. > [!IMPORTANT] > Critical information users should not miss. > [!WARNING] > Potential issues users should be aware of. > [!CAUTION] > Dangerous actions that could cause problems. Troubleshooting Pages Troubleshooting pages help readers solve problems. Structure each issue with the error message, cause, and solution. Troubleshooting Pattern Module Not Found Error Message Show the exact error: Error: Cannot find module &x27;example-package&x27; at Function.Module.resolveFilename (node:internal/modules/cjs/loader:933:15) Then explain and solve: Cause The required package is not installed in your nodemodules directory. Solution Install the missing package: npm install example-package Add helpful context: > [!TIP] > Run npm ls example-package to check if a package is installed. FAQ Pages FAQ pages answer common questions concisely. Group related questions under headings. FAQ Pattern Getting Started Do I need a database? No. The application runs without a database by default, storing data in memory. For production use, we recommend connecting a persistent database. What Node.js version do I need? Node.js 18 or later. Check your version with: node --version Configuration How do I change the default port? Set the PORT environment variable: PORT=8080 npm start Best Practices When creating documentation pages: Start with frontmatter - Always include title and description Use clear headings - Structure content with and headings Show, donâ€™t just tell - Include code examples for technical content Add callouts sparingly - Use alerts for genuinely important information Link to related pages - Help readers discover more content End with next steps - Guide readers to continue their journey TIP When creating new pages, copy the structure from similar existing pages and modify for your needs. Consistent structure helps readers navigate your documentation."
  },
  {
    "title": "Frontmatter",
    "url": "/authoring-content/frontmatter",
    "description": "Complete guide to YAML frontmatter in MarkStack, including available fields, best practices for titles and descriptions, and how frontmatter affects navigation, search, and SEO.",
    "content": "Frontmatter Frontmatter is metadata written in YAML format at the very beginning of each markdown file. It tells MarkStack how to title the page, what description to use in search results and meta tags, and provides other information that affects how the page appears on your site. This guide explains all available frontmatter fields, how to write effective values, and best practices for different types of pages. What Frontmatter Looks Like Frontmatter appears at the top of a markdown file, wrapped in triple dashes: --- title: Getting Started description: Learn how to install, configure, and run your first build. --- Getting Started The rest of your content goes here... The triple dashes ( --- ) mark where the frontmatter begins and ends. Everything between them is YAML, a simple format for key-value pairs. Everything after the closing dashes is your markdown content. Available Fields MarkStack currently supports two frontmatter fields: title The title field sets the page title. This value appears in: The browser tab/window title The sidebar navigation label The breadcrumb trail The pageâ€™s HTML <title> tag Open Graph meta tags for social sharing --- title: Installation Guide --- When to use: Always set a title for important pages. It gives you control over exactly how the page appears in navigation and search results. When it is optional: If you omit the title, MarkStack derives one from the filename: Filename Derived Title installation.md Installation quick-start.md Quick Start api-reference.md Api Reference The derived title applies basic formatting (replacing hyphens with spaces, capitalizing first letters), but it may not be exactly what you want. For example, â€œ api-reference.md â€ becomes â€œApi Referenceâ€ rather than â€œAPI Reference.â€ description The description field provides a short summary of what the page covers. This value appears in: The HTML <meta name=\"description\"> tag (important for SEO) Search result snippets in the MarkStack search box Open Graph meta tags when the page is shared on social media --- title: Installation Guide description: Step-by-step instructions for installing the software on Windows, macOS, and Linux, including prerequisites and troubleshooting tips. --- When to use: Add descriptions to every page you want to be discoverable in search engines. The description helps users decide whether a search result is relevant to their needs. When it is optional: If you omit the description, MarkStack uses the defaultDescription from siteconfig.json . This fallback works for pages you do not expect search engines to surface prominently, but it means all those pages show the same generic description in search results. Frontmatter for Categories Category landing pages ( index.md files) use the same frontmatter fields, but they apply to the entire category: --- title: Guides description: Step-by-step tutorials that walk you through common tasks from start to finish. --- Guides Welcome to the guides section... The title becomes the sidebar label for the category folder. The description appears in the category landing pageâ€™s meta tags. Without frontmatter, the category title comes from the folder name. A folder named getting-started/ without an index.md (or with an _index.md missing the title) appears in navigation as â€œGetting Started.â€ Writing Effective Titles Good titles help readers find information quickly and understand what a page covers. Follow these guidelines: Be Specific Vague titles make navigation harder. Compare: Less Effective More Effective Setup Installation on Windows Guide Complete API Authentication Guide Config Configuration File Reference Keep Titles Concise Long titles clutter the sidebar and get truncated in browser tabs. Aim for 3 to 5 words when possible: Too Long Better A Complete Guide to Installing and Configuring the Software on Your Machine Installation Guide Everything You Need to Know About the Configuration File Configuration Reference Use Consistent Patterns Pick a capitalization style and stick with it throughout your documentation: Title Case : Installation Guide, API Reference, Getting Started Sentence case : Installation guide, API reference, Getting started Most documentation uses title case for navigation items. Remember That Titles Become URLs Since titles slugify into URLs, consider how the slug will look: Title Resulting URL Getting Started /getting-started/ C++ Programming Guide /c-programming-guide/ The â€œUltimateâ€ Reference /the-ultimate-reference/ Titles with special characters may produce less readable URLs. â€œC++ Programming Guideâ€ loses the plus signs and becomes c-programming-guide . Writing Effective Descriptions Descriptions serve readers and search engines. A good description: Summarizes the page content accurately Helps readers decide if this page answers their question Uses natural language (not just keywords) Fits in the space search engines display (about 150 to 160 characters) Examples Good description: description: Learn how to install MarkStack on Windows, macOS, and Linux with step-by-step instructions and troubleshooting tips for common issues. This description tells readers exactly what they will find and includes relevant terms naturally. Less effective description: description: Installation. Setup. Configuration. Download. Install software. Getting started guide. This reads like a keyword list, not helpful information. Description Length Search engines typically display 150 to 160 characters of the description. Longer descriptions get truncated with an ellipsis (â€¦). Check your description length: Under 150 characters: Safe, will display fully 150 to 160 characters: Usually displays fully Over 160 characters: Will be truncated This description is about 140 characters: description: Install MarkStack in minutes with our step-by-step guide. Covers Windows, macOS, and Linux with troubleshooting tips. When Pages Share Descriptions If you omit descriptions from multiple pages, they all inherit defaultDescription from siteconfig.json . This makes search results less helpful because every page shows the same snippet. Prioritize adding unique descriptions to: Landing pages (homepage, category indexes) Frequently accessed pages Pages you want search engines to rank Complete Examples Documentation Page --- title: API Authentication description: Configure API keys and OAuth tokens to authenticate requests. Includes examples for all supported authentication methods. --- API Authentication This guide explains how to authenticate API requests using API keys, OAuth 2.0 tokens, or service accounts. API Keys Generate an API key from your dashboard... Category Landing Page --- title: Developer Guides description: In-depth guides for developers integrating with our platform. Covers authentication, webhooks, SDKs, and best practices. --- Developer Guides These guides help developers build integrations with our platform. Where to Start New developers should begin with the Quick Start tutorial... Minimal Page For less important pages, you can use minimal frontmatter: --- title: Changelog --- Changelog Version 2.1.0 Released December 15, 2024... This page uses the title from frontmatter and inherits the siteâ€™s default description. Frontmatter Best Practices Practice Reason Always set title Gives you control over navigation and URLs Add description to important pages Improves search results and SEO Keep titles stable Changing titles changes URLs, breaking links Use natural language in descriptions Helps readers, not just search engines Review descriptions for length Keep under 160 characters to avoid truncation What Happens After Changes After modifying frontmatter, run npm run build (or let npm run watch rebuild automatically). The build process: Reads the new frontmatter values Regenerates the URL if the title changed Updates meta tags in the HTML output Rebuilds the search index with new titles and descriptions Updates navigation labels in the sidebar WARNING Changing a pageâ€™s title changes its URL. If the page is already published and linked from external sites, those links will break. Either keep titles stable after publishing, or add redirects at your hosting provider when you must change them. TIP When creating new content, set the title and description in frontmatter before writing the content. This helps you stay focused on what the page should cover."
  },
  {
    "title": "Markdown Features",
    "url": "/authoring-content/markdown-features",
    "description": "Complete reference for all markdown syntax supported in MarkStack, including GitHub-style alerts, syntax-highlighted code blocks, task lists, footnotes, tables, images, and links.",
    "content": "Markdown Features MarkStack extends standard markdown with features commonly used in technical documentation. This guide covers every formatting option available, with examples you can copy directly into your own pages. The markdown processor is based on markdown-it with plugins for: Heading anchors (clickable links for each heading) GitHub-style callout alerts Task list checkboxes Footnotes with automatic numbering Syntax highlighting for code blocks Standard Markdown Before covering the extensions, here is a quick reference for standard markdown syntax that works everywhere. Headings Use hash symbols to create headings. More hashes mean smaller headings: Heading 1 Heading 2 Heading 3 Heading 4 Heading 5 Heading 6 Each heading automatically gets an anchor link (the symbol that appears when you hover). Readers can click these to get a direct URL to that section. Paragraphs Paragraphs are separated by blank lines: This is the first paragraph. It can span multiple lines in the source and will render as continuous text. This is the second paragraph, separated by a blank line. Emphasis italic text or italic text bold text or bold text bold and italic or _ bold and italic ~~strikethrough text~~ Renders as: italic , bold , bold and italic , strikethrough . Lists Unordered lists use dashes, asterisks, or plus signs: First item Second item Nested item Another nested item Third item Ordered lists use numbers: First step Second step Sub-step A Sub-step B Third step The actual numbers do not matter. Markdown renumbers them automatically. You could write 1. 1. 1. and it would render as 1. 2. 3. Blockquotes Use the greater-than symbol for quoted text: > This is a blockquote. It can span multiple lines > and represent quoted material or callouts. > Multiple paragraphs work within blockquotes too. Horizontal Rules Create a horizontal line with three or more dashes, asterisks, or underscores: --- or Inline Code Wrap code in backticks for inline code: Use the npm run build command to generate your site. Renders as: Use the npm run build command to generate your site. GitHub-Style Alerts Alerts are styled callout boxes that highlight important information. They are perfect for notes, tips, warnings, and other messages that should stand out from regular text. MarkStack supports five alert types, matching GitHubâ€™s markdown alert syntax: NOTE Use NOTE for general information readers should notice while scanning: > [!NOTE] > MarkStack requires Node.js version 18 or later. Check your version with node --version. Renders as: NOTE MarkStack requires Node.js version 18 or later. Check your version with node --version . TIP Use TIP for optional suggestions that help readers work more effectively: > [!TIP] > Run npm run watch in one terminal and npm run serve in another for the fastest development workflow. Renders as: TIP Run npm run watch in one terminal and npm run serve in another for the fastest development workflow. IMPORTANT Use IMPORTANT for information critical to completing a task successfully: > [!IMPORTANT] > Back up your database before running the migration script. This operation cannot be undone. Renders as: IMPORTANT Back up your database before running the migration script. This operation cannot be undone. WARNING Use WARNING for situations that could cause problems if ignored: > [!WARNING] > Changing the title in frontmatter will change the page URL, potentially breaking existing links. Renders as: WARNING Changing the title in frontmatter will change the page URL, potentially breaking existing links. CAUTION Use CAUTION for actions that could have serious negative consequences: > [!CAUTION] > Running npm run clean deletes the entire dist/ folder. Make sure you have not stored any important files there. Renders as: CAUTION Running npm run clean deletes the entire dist/ folder. Make sure you have not stored any important files there. Alert Syntax Rules For alerts to render correctly: Start with a blockquote marker ( > ) Put the alert type marker [!TYPE] immediately after, on its own line Write the alert content on following lines with blockquote markers > [!NOTE] > This is the correct syntax. > The content can span multiple lines. The alert type must be uppercase: [!NOTE] , not [!Note] or [!note] . When to Use Each Alert Type Type Purpose Example Use Case NOTE General context Version requirements, related links TIP Helpful suggestions Keyboard shortcuts, workflow tips IMPORTANT Required information Critical configuration steps WARNING Potential issues Side effects, prerequisites CAUTION Dangerous actions Data loss, irreversible operations Code Blocks Code blocks display source code with syntax highlighting. MarkStack uses Highlight.js, which supports over 190 programming languages. Basic Code Block Wrap code in triple backticks with the language name: ``javascript function greet(name) { console.log(Hello, ${name}!); } greet(&x27;World&x27;); ` Renders as: function greet ( name ) { console . log ( Hello, ${name} ! ); } greet ( &x27;World&x27; ); Specifying the Language Always specify a language for proper syntax highlighting. The language name appears as a label above the code block. Common language identifiers: Language Identifier JavaScript javascript or js TypeScript typescript or ts Python python or py Bash/Shell bash or shell JSON json YAML yaml HTML html CSS css SQL sql Markdown markdown or md C c C++ cpp Ccsharp or cs Java java Ruby ruby or rb Go go Rust rust PHP php Examples in Different Languages Python: def calculatetotal ( items ): \"\"\"Calculate the total price of all items.\"\"\" return sum (item[ &x27;price&x27; ] * item[ &x27;quantity&x27; ] for item in items) cart = [ { &x27;name&x27; : &x27;Widget&x27; , &x27;price&x27; : 9.99 , &x27;quantity&x27; : 2 }, { &x27;name&x27; : &x27;Gadget&x27; , &x27;price&x27; : 24.99 , &x27;quantity&x27; : 1 } ] print ( f\"Total: $ {calculate_total(cart): .2 f} \" ) Bash: !/bin/bash Build and deploy the documentation npm run clean npm run build if [ -d \"dist\" ]; then echo \"Build successful, deploying...\" rsync -avz dist/ user@server:/var/www/docs/ else echo \"Build failed!\" exit 1 fi JSON: { \"siteTitle\" : \"My Documentation\" , \"headerTitle\" : \"MyDocs\" , \"siteSubtitle\" : \"Complete guides and references\" , \"siteUrl\" : \"https://docs.example.com\" , \"showHero\" : true } YAML: name: Deploy Documentation on: push: branches: [ main ] jobs: build: runs-on: ubuntu-latest steps: uses: actions/checkout@v4 uses: actions/setup-node@v4 with: node-version: &x27;20&x27; run: npm ci run: npm run build Plain Text Code Blocks If you do not specify a language, or specify an unrecognized language, the code renders as plain text without highlighting: ` This is plain text without syntax highlighting. It preserves whitespace and formatting. `` Copy Button Every code block automatically includes a Copy button in the top-right corner. Readers can click this button to copy the code to their clipboard without manually selecting it. Task Lists Task lists create checkboxes for tracking items. They are useful for checklists, requirements, or step-by-step processes: [x] Install Node.js [x] Clone the repository [x] Run npm install [ ] Configure siteconfig.json [ ] Add your content [ ] Deploy to production Renders as: Install Node.js Clone the repository Run npm install Configure siteconfig.json Add your content Deploy to production Task List Syntax [ ] creates an unchecked box (space between brackets) [x] creates a checked box (x between brackets) Use lowercase x , not uppercase X Task lists are read-only in the rendered HTML. Readers cannot interact with the checkboxes on the generated site. Footnotes Footnotes let you add references, citations, or extended explanations without cluttering the main text: Documentation sites should be fast and searchable[^1]. MarkStack achieves sub-100ms build times for most sites[^2]. [ ^1 ]: According to studies, users abandon slow-loading documentation within seconds. [ ^2 ]: Based on testing with documentation sites containing up to 500 pages. How Footnotes Work In your text, add a footnote marker: [^1] , [^note] , [^ref-name] Define the footnote content anywhere in the file: [^1]: Footnote text here All footnotes render at the bottom of the page, numbered automatically Footnote Naming Footnote markers can be numbers or descriptive names: See the official specification[^spec] for details. [ ^spec ]: The specification is available at https://example.com/spec The rendered page shows sequential numbers regardless of marker names. Tables Tables present structured data in rows and columns: | Feature | Supported | Notes | |---------|-----------|-------| | Syntax highlighting | Yes | 190+ languages via Highlight.js | | GitHub alerts | Yes | NOTE, TIP, IMPORTANT, WARNING, CAUTION | | Task lists | Yes | Read-only checkboxes | | Footnotes | Yes | Auto-numbered at page bottom | | Math equations | No | Not included by default | Renders as: Feature Supported Notes Syntax highlighting Yes 190+ languages via Highlight.js GitHub alerts Yes NOTE, TIP, IMPORTANT, WARNING, CAUTION Task lists Yes Read-only checkboxes Footnotes Yes Auto-numbered at page bottom Math equations No Not included by default Table Alignment Control column alignment with colons in the separator row: | Left | Center | Right | |:-----|:------:|------:| | Text | Text | Text | | More | More | More | Left Center Right Text Text Text More More More Table Tips Keep tables simple. Complex tables are hard to read and maintain in markdown. Use the same number of columns in every row. The separator row ( |---| ) can have any number of dashes, but at least three. Leading and trailing pipes ( | ) are optional but recommended for readability. Images Add images to your documentation by placing them in the static/ folder and referencing them with absolute paths. Adding an Image Put the image in static/images/ (create the folder if it does not exist) Reference it in markdown: ! Diagram showing the build pipeline The text in brackets is the alt text, which describes the image for accessibility. Image Syntax ! Alt text ! Alt text The optional title appears as a tooltip when hovering over the image. Image Best Practices Practice Reason Use descriptive alt text Helps screen reader users and shows if image fails to load Use absolute paths ( /images/... ) Works from any page on the site Optimize image file sizes Large images slow down page loading Use SVG for diagrams Scales without quality loss Use PNG for screenshots Good quality with transparency support Use JPG for photographs Smaller file sizes for photo content Links Links connect pages and point to external resources. Internal Links Link to other pages in your documentation with absolute paths: See the Installation Guide for setup instructions. Check Frontmatter for metadata options. Use trailing slashes for consistency with the generated URLs. External Links Link to external websites: Node.js is required for running MarkStack. Highlight.js provides code highlighting. The optional title text appears as a tooltip on hover. Link Best Practices Practice Reason Use descriptive link text â€œRead the installation guideâ€ is better than â€œclick hereâ€ Use absolute paths for internal links Works from any page Include trailing slashes Matches generated URL structure Test links after renaming pages Titles change URLs, breaking links Heading Anchors Every heading automatically gets an anchor ID that allows direct linking: Installation Steps Generates HTML with an ID: < h2 id = \"installation-steps\" > Installation Steps </ h2 > Link directly to this section with: See the Installation Steps section. The anchor ID is the heading text, lowercased, with spaces replaced by hyphens and special characters removed. TIP Hover over any heading on a MarkStack page to see the anchor link icon (). Click it to copy the direct URL to that section."
  },
  {
    "title": "Media and Links",
    "url": "/authoring-content/media-and-links",
    "description": "Complete guide to adding images, downloadable files, and links in MarkStack documentation, including file organization, path conventions, and accessibility best practices.",
    "content": "Media and Links This guide covers everything about adding non-text content to your documentation: images, downloadable files, and links to other pages. Understanding these conventions ensures your assets load correctly and your links work reliably. Understanding Static Assets MarkStack copies everything in the static/ folder to dist/ during each build. This is where you place files you want to serve alongside your documentation: static/ â”œâ”€â”€ css/ Stylesheets â”œâ”€â”€ js/ JavaScript â”œâ”€â”€ svg/ SVG files (logo, icons) â”œâ”€â”€ images/ PNG, JPG, GIF images â””â”€â”€ files/ Downloadable documents (PDFs, ZIPs) When you reference these files in markdown, use absolute paths starting with / : static/images/diagram.png becomes /images/diagram.png static/files/guide.pdf becomes /files/guide.pdf Images Images enhance documentation by showing concepts visually, providing screenshots of interfaces, and displaying diagrams that would be difficult to explain in words. Adding Images to Your Project Create an images folder if it does not exist: static/images/ Copy your image file into that folder Reference it in your markdown ! Descriptive alt text Image Syntax The basic syntax for images is: ! Alt text You can add an optional title that appears as a tooltip: ! Alt text Complete Example Suppose you have a screenshot of the MarkStack sidebar. You would: Save it as static/images/sidebar-screenshot.png Reference it in markdown: The sidebar shows your documentation structure: ! Screenshot of the MarkStack sidebar navigation Click any item to navigate to that page. Image Organization For sites with many images, organize them into subfolders: static/images/ â”œâ”€â”€ getting-started/ â”‚ â”œâ”€â”€ install-step-1.png â”‚ â””â”€â”€ install-step-2.png â”œâ”€â”€ guides/ â”‚ â”œâ”€â”€ dashboard-overview.png â”‚ â””â”€â”€ settings-panel.png â””â”€â”€ diagrams/ â”œâ”€â”€ architecture.svg â””â”€â”€ data-flow.svg Reference them with the full path: ! Installation step 1 SVG Files SVG (Scalable Vector Graphics) files are ideal for diagrams, logos, and icons because they scale without losing quality. Store them in static/svg/ or static/images/ : ! System architecture Image Format Guidelines Format Best For Characteristics PNG Screenshots, UI elements Lossless, supports transparency JPG Photographs, complex images Smaller files, no transparency SVG Diagrams, logos, icons Scalable, small file size GIF Simple animations Limited colors, animation support WebP Modern browsers Best compression, broad support Image Optimization Large images slow down page loading. Optimize images before adding them: Resize images to the maximum size they will display (no need for 4000px images if they display at 800px) Compress using tools like ImageOptim, TinyPNG, or Squoosh Use appropriate formats (PNG for screenshots, JPG for photos) Consider SVG for diagrams and illustrations Why Absolute Paths Matter Always use absolute paths starting with / for images: <!-- Correct: absolute path --> ! Diagram <!-- Incorrect: relative path --> ! Diagram ! Diagram Absolute paths work from any page regardless of nesting depth. Relative paths break when pages move or when the same content appears at different URL depths. Downloadable Files Provide downloadable content like PDFs, ZIP archives, or sample files by placing them in static/files/ and linking to them. Adding Downloadable Files Create the files folder: static/files/ Add your file (e.g., user-guide.pdf ) Link to it in markdown: Download the complete User Guide (PDF) . Common File Types File Type Example Path Use Case PDF documents /files/user-guide.pdf Printable guides, specifications ZIP archives /files/sample-project.zip Code samples, starter kits Configuration files /files/config-template.yaml Templates for users to download Data files /files/sample-data.csv Example datasets File Organization For many downloadable files, organize by category: static/files/ â”œâ”€â”€ guides/ â”‚ â”œâ”€â”€ getting-started.pdf â”‚ â””â”€â”€ advanced-usage.pdf â”œâ”€â”€ samples/ â”‚ â”œâ”€â”€ starter-project.zip â”‚ â””â”€â”€ example-config.yaml â””â”€â”€ reference/ â””â”€â”€ api-specification.pdf Reference with full paths: Download the starter project Internal Links Internal links connect pages within your documentation. They help readers navigate to related content and create a cohesive documentation experience. Link Syntax Link text Linking to Pages Link to other documentation pages using their URL path: See the Installation Guide for setup instructions. Review the Configuration Reference for all options. Linking to Category Landing Pages Category landing pages end with a trailing slash: Explore the Authoring Content section for writing guides. Linking to Page Sections Link to specific sections using anchor IDs: See the Code Blocks section below. Refer to the GitHub Actions example . Anchor IDs are generated from heading text: lowercased, spaces become hyphens, special characters removed. Best Practices for Internal Links Practice Example Use absolute paths /authoring/frontmatter/ not ../frontmatter/ Include trailing slashes /getting-started/ not /getting-started Use descriptive link text â€œread the installation guideâ€ not â€œclick hereâ€ Check links after renaming Title changes break links based on old slugs Example: Navigation Links Create a â€œRelated Pagesâ€ section at the bottom of pages: Related Pages Markdown Features for formatting options Frontmatter for metadata fields Examples for copy-ready templates External Links External links point to resources outside your documentation site. Basic External Links Node.js is required to run MarkStack. External Links with Titles Add tooltip text with a title: Highlight.js provides code highlighting. When to Link Externally External links are helpful for: Official documentation of tools you reference Specifications and standards Additional resources for deeper learning Credit and attribution External Link Considerations External links can break if the destination page moves or disappears. Consider: Linking to stable, authoritative sources (official documentation, specifications) Periodically checking that external links still work Avoiding links to content that changes frequently Accessibility Accessible documentation works for everyone, including people using screen readers, keyboard navigation, or other assistive technologies. Alt Text for Images Every image needs descriptive alt text that conveys the imageâ€™s purpose: <!-- Good: describes what the image shows --> ! Flowchart showing the build pipeline from content to dist folder <!-- Bad: unhelpful alt text --> ! Image If an image is purely decorative and adds no information, you can use empty alt text: However, documentation images almost always convey information and need meaningful alt text. Writing Good Alt Text Image Type Alt Text Approach Screenshot Describe what the interface shows and any highlighted elements Diagram Summarize the relationships or flow depicted Graph/Chart Describe the data and any key insights Icon Describe the iconâ€™s meaning in context Examples: ! MarkStack homepage showing the search bar and navigation sidebar ! Diagram of request flow: client sends request to API, API queries database, database returns data ! Bar chart showing build times: MarkStack at 89ms, Tool B at 2400ms, Tool C at 5600ms Descriptive Link Text Link text should describe where the link goes: <!-- Good: describes the destination --> Read the installation guide for setup instructions. Download the complete API reference (PDF) . <!-- Bad: generic link text --> Click here for installation. Download the reference. Screen reader users often navigate by links, hearing just the link text without surrounding context. â€œClick hereâ€ and â€œdownloadâ€ do not tell them where the link leads. Link Purpose from Context If context makes the destination clear, shorter link text works: For setup help, see Installation . Practical Examples Documentation Page with Multiple Assets --- title: Dashboard Overview description: Learn to navigate and customize the dashboard interface. --- Dashboard Overview The dashboard is your central hub for monitoring system status. ! Dashboard main view showing navigation and status panels Navigation The left sidebar provides access to all major sections: ! Sidebar navigation highlighting the main menu items Customization Download our dashboard configuration template to get started with customization. For detailed customization options, see the Configuration Guide . > [!TIP] > Press Ctrl+K anywhere in the dashboard to open the quick search. Linking Related Content Learn More Getting Started provides initial setup instructions Markdown Features covers all formatting options Highlight.js powers the syntax highlighting For printable reference material: Quick Reference Card (PDF) Full Documentation (PDF) TIP After adding new files to static/ , run npm run build (or let npm run watch rebuild) so they copy to dist/ and become accessible."
  },
  {
    "title": "Authoring Content",
    "url": "/authoring-content/",
    "description": "Complete guide to writing documentation in MarkStack, covering the content model, frontmatter metadata, markdown features, media handling, and copy-ready examples.",
    "content": "Authoring Content This section teaches you everything about writing documentation in MarkStack. You will learn how to organize content, use frontmatter for metadata, leverage markdown extensions for rich formatting, and follow best practices that make your documentation clear and maintainable. MarkStack extends standard markdown with GitHub-style features like callout alerts, task lists, footnotes, and syntax-highlighted code blocks. Understanding these features helps you create documentation that communicates effectively and looks professional. What This Section Covers Content Model The Content Model guide explains how MarkStack organizes documentation: How folders become navigation categories How markdown files become documentation pages The role of _index.md files for category landing pages How titles transform into URL slugs Strategies for organizing large documentation projects How nesting and ordering work Understanding the content model is essential. It determines how your documentation appears in the sidebar, how URLs generate, and how readers navigate your site. Frontmatter The Frontmatter guide covers the YAML metadata at the top of each markdown file: The title field and how it affects navigation, page titles, and URLs The description field and its role in search results and SEO How frontmatter interacts with siteconfig.json defaults Best practices for writing effective titles and descriptions Good frontmatter makes your documentation discoverable in search engines and helps readers understand what each page contains before clicking. Markdown Features The Markdown Features guide documents everything you can do with markdown in MarkStack: Standard markdown syntax (headings, paragraphs, lists, links, images) GitHub-style callout alerts (NOTE, TIP, IMPORTANT, WARNING, CAUTION) Fenced code blocks with syntax highlighting for 190+ languages Task lists with checkboxes Footnotes for references and citations Tables for structured data Horizontal rules and other formatting Each feature includes examples you can copy directly into your documentation. Media and Links The Media and Links guide covers how to include assets and create connections: Where to place images and how to reference them Handling downloadable files like PDFs Internal linking between documentation pages External links to other websites Accessibility best practices for images and links Proper linking ensures your documentation works correctly after deployment and provides a good experience for all readers. Examples The Examples page provides ready-to-use templates: Category landing pages with navigation Standard documentation pages with frontmatter Pages using multiple markdown features together Common patterns you can adapt for your needs These examples help you start new pages quickly without recreating boilerplate. Recommended Reading Order If you are new to writing documentation in MarkStack, read these guides in order: Content Model first, to understand how organization works Frontmatter second, to learn about metadata Markdown Features third, for formatting options Media and Links fourth, for asset handling Examples as needed, when creating new content If you already know markdown basics, you can skip to specific guides for the information you need. Quick Tips for Good Documentation As you work through this section, keep these principles in mind: Principle How to Apply It Clear titles Use descriptive titles that tell readers what the page covers Helpful descriptions Write descriptions that appear in search results and help readers decide whether to read the page Scannable structure Use headings, lists, and tables so readers can find information quickly Working examples Include code samples readers can copy and use directly Consistent style Follow the same patterns throughout your documentation TIP As you read through this section, have a markdown file open in your editor. Try each feature as you learn about it. The immediate feedback helps concepts stick."
  },
  {
    "title": "CI/CD Integration",
    "url": "/build-and-deploy/cicd-integration",
    "description": "Set up automated builds and deployments for your MarkStack site using GitHub Actions, GitLab CI, and other continuous integration systems.",
    "content": "CI/CD Integration Continuous Integration and Continuous Deployment (CI/CD) automates building and deploying your MarkStack site whenever you push changes. This guide covers setting up automated pipelines for popular platforms. Benefits of CI/CD Automated deployments provide several advantages: Consistency : Every build uses the same environment and steps Speed : Deploy seconds after pushing, no manual steps Reliability : Catch build errors before they reach production Collaboration : Team members can contribute without deployment access Audit trail : Git history shows what was deployed and when GitHub Actions GitHub Actions is integrated directly into GitHub and requires no additional services. Basic Deployment Workflow Create .github/workflows/deploy.yml : name: Build and Deploy on: push: branches: [ main ] pullrequest: branches: [ main ] workflowdispatch: jobs: build: runs-on: ubuntu-latest steps: name: Checkout repository uses: actions/checkout@v4 name: Setup Node.js uses: actions/setup-node@v4 with: node-version: &x27;20&x27; cache: &x27;npm&x27; name: Install dependencies run: npm ci name: Build site run: npm run build name: Upload build artifact uses: actions/upload-artifact@v4 with: name: dist path: dist/ retention-days: 7 This workflow: Runs on every push to main Runs on pull requests (for testing) Can be triggered manually Caches npm dependencies for faster builds Uploads the built site as an artifact Deploy to GitHub Pages For GitHub Pages deployment, use this workflow: name: Deploy to GitHub Pages on: push: branches: [ main ] workflowdispatch: permissions: contents: read pages: write id-token: write concurrency: group: \"pages\" cancel-in-progress: true jobs: build: runs-on: ubuntu-latest steps: name: Checkout uses: actions/checkout@v4 name: Setup Node.js uses: actions/setup-node@v4 with: node-version: &x27;20&x27; cache: &x27;npm&x27; name: Install dependencies run: npm ci name: Build site run: npm run build name: Configure Pages uses: actions/configure-pages@v4 name: Upload Pages artifact uses: actions/upload-pages-artifact@v3 with: path: ./dist deploy: needs: build runs-on: ubuntu-latest environment: name: github-pages url: ${{ steps.deployment.outputs.pageurl }} steps: name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v4 After adding this workflow: Go to repository Settings Navigate to Pages Under â€œBuild and deploymentâ€, select â€œGitHub Actionsâ€ Deploy to Netlify name: Deploy to Netlify on: push: branches: [ main ] jobs: deploy: runs-on: ubuntu-latest steps: name: Checkout uses: actions/checkout@v4 name: Setup Node.js uses: actions/setup-node@v4 with: node-version: &x27;20&x27; cache: &x27;npm&x27; name: Install dependencies run: npm ci name: Build site run: npm run build name: Deploy to Netlify uses: nwtgck/actions-netlify@v3 with: publish-dir: &x27;./dist&x27; production-branch: main production-deploy: true env: NETLIFYAUTHTOKEN: ${{ secrets.NETLIFYAUTHTOKEN }} NETLIFYSITEID: ${{ secrets.NETLIFYSITEID }} To get the required secrets: NETLIFYAUTHTOKEN : Create at Netlify User Settings under Applications NETLIFYSITEID : Found in Site Configuration under General Add these as repository secrets in GitHub Settings. Deploy to Vercel name: Deploy to Vercel on: push: branches: [ main ] jobs: deploy: runs-on: ubuntu-latest steps: name: Checkout uses: actions/checkout@v4 name: Setup Node.js uses: actions/setup-node@v4 with: node-version: &x27;20&x27; cache: &x27;npm&x27; name: Install dependencies run: npm ci name: Build site run: npm run build name: Deploy to Vercel uses: amondnet/vercel-action@v25 with: vercel-token: ${{ secrets.VERCELTOKEN }} vercel-org-id: ${{ secrets.VERCELORGID }} vercel-project-id: ${{ secrets.VERCELPROJECTID }} working-directory: ./dist vercel-args: &x27;--prod&x27; Pull Request Previews Deploy preview versions for pull requests: name: Deploy Preview on: pullrequest: types: [ opened , synchronize , reopened ] jobs: preview: runs-on: ubuntu-latest steps: name: Checkout uses: actions/checkout@v4 name: Setup Node.js uses: actions/setup-node@v4 with: node-version: &x27;20&x27; cache: &x27;npm&x27; name: Install dependencies run: npm ci name: Build site run: npm run build name: Deploy Preview to Netlify uses: nwtgck/actions-netlify@v3 with: publish-dir: &x27;./dist&x27; production-deploy: false github-token: ${{ secrets.GITHUBTOKEN }} deploy-message: &x27;PR Preview: ${{ github.event.pullrequest.title }}&x27; env: NETLIFYAUTHTOKEN: ${{ secrets.NETLIFYAUTHTOKEN }} NETLIFYSITEID: ${{ secrets.NETLIFYSITEID }} This posts a comment on the PR with a link to the preview deployment. GitLab CI GitLab CI uses a .gitlab-ci.yml file in your repository root. Basic Pipeline image: node:20-alpine stages: build deploy cache: key: ${CICOMMITREFSLUG} paths: nodemodules/ build: stage: build script: npm ci npm run build artifacts: paths: dist/ expirein: 1 week pages: stage: deploy script: mv dist public artifacts: paths: public only: main This deploys to GitLab Pages. The site will be at https://username.gitlab.io/repository-name/ . Deploy to External Host image: node:20-alpine stages: build deploy build: stage: build script: npm ci npm run build artifacts: paths: dist/ expirein: 1 day deployproduction: stage: deploy image: alpine:latest beforescript: apk add --no-cache rsync openssh-client eval $(ssh-agent -s) echo \"$SSHPRIVATEKEY\" | tr -d &x27;\\r&x27; | ssh-add - mkdir -p ~/.ssh chmod 700 ~/.ssh echo \"$SSHKNOWNHOSTS\" >> ~/.ssh/knownhosts script: rsync -avz --delete dist/ $DEPLOYUSER@$DEPLOYHOST:$DEPLOYPATH only: main environment: name: production url: https://docs.yoursite.com Required CI/CD variables: SSHPRIVATEKEY : Private key for server access SSHKNOWNHOSTS : Serverâ€™s SSH host key DEPLOYUSER : SSH username DEPLOYHOST : Server hostname DEPLOYPATH : Target directory on server Azure DevOps Pipelines Create azure-pipelines.yml : trigger: branches: include: main pool: vmImage: &x27;ubuntu-latest&x27; steps: task: NodeTool@0 inputs: versionSpec: &x27;20.x&x27; displayName: &x27;Install Node.js&x27; script: npm ci displayName: &x27;Install dependencies&x27; script: npm run build displayName: &x27;Build site&x27; task: PublishBuildArtifacts@1 inputs: pathToPublish: &x27;dist&x27; artifactName: &x27;site&x27; displayName: &x27;Publish artifact&x27; Deploy to Azure Static Web Apps trigger: branches: include: main pool: vmImage: &x27;ubuntu-latest&x27; steps: task: NodeTool@0 inputs: versionSpec: &x27;20.x&x27; script: npm ci displayName: &x27;Install dependencies&x27; script: npm run build displayName: &x27;Build site&x27; task: AzureStaticWebApp@0 inputs: applocation: &x27;/&x27; outputlocation: &x27;dist&x27; env: azurestaticwebappsapitoken: $(AZURESTATICWEBAPPSAPITOKEN) CircleCI Create .circleci/config.yml : version: 2.1 executors: node-executor: docker: image: cimg/node:20.0 jobs: build: executor: node-executor steps: checkout restorecache: keys: npm-deps-{{ checksum \"package-lock.json\" }} npm-deps- run: name: Install dependencies command: npm ci savecache: key: npm-deps-{{ checksum \"package-lock.json\" }} paths: nodemodules run: name: Build site command: npm run build persisttoworkspace: root: . paths: dist deploy: executor: node-executor steps: attachworkspace: at: . run: name: Deploy to hosting command: | Add your deployment commands here echo \"Deploying dist/ folder\" workflows: build-and-deploy: jobs: build deploy: requires: build filters: branches: only: main Build Caching Caching dependencies speeds up CI builds significantly. npm Cache Most CI systems support caching nodemodules : GitHub Actions: uses: actions/setup-node@v4 with: node-version: &x27;20&x27; cache: &x27;npm&x27; GitLab CI: cache: key: ${CICOMMITREFSLUG} paths: nodemodules/ CircleCI: restorecache: keys: npm-deps-{{ checksum \"package-lock.json\" }} Environment Variables Store sensitive values as secrets, not in your repository. Common Secrets Secret Purpose NETLIFYAUTHTOKEN Netlify API authentication NETLIFYSITEID Target Netlify site VERCELTOKEN Vercel API authentication SSHPRIVATEKEY Server access for self-hosting Adding Secrets GitHub: Settings > Secrets and variables > Actions > New repository secret GitLab: Settings > CI/CD > Variables CircleCI: Project Settings > Environment Variables Build Notifications Slack Notifications Add to your GitHub Actions workflow: name: Notify Slack if: always() uses: 8398a7/action-slack@v3 with: status: ${{ job.status }} fields: repo,message,commit,author,action,eventName,ref,workflow env: SLACKWEBHOOKURL: ${{ secrets.SLACKWEBHOOKURL }} Email Notifications Most CI platforms send email notifications by default for failed builds. Check platform settings to configure. Troubleshooting CI Builds Build Fails in CI but Works Locally Common causes: Missing dependencies : Ensure package-lock.json is committed Node version mismatch : Specify exact version in CI Case sensitivity : Linux is case-sensitive, Windows/Mac are not Missing files : Check .gitignore is not excluding needed files Slow Builds Improve build speed: Enable dependency caching Use npm ci instead of npm install Use lightweight base images Avoid unnecessary steps Debug CI Issues Add debug output: name: Debug info run: | node --version npm --version ls -la cat package.json TIP Most CI platforms allow re-running failed jobs with SSH access for debugging. Check your platformâ€™s documentation for this feature."
  },
  {
    "title": "Commands Reference",
    "url": "/build-and-deploy/commands-reference",
    "description": "Complete reference for all MarkStack npm commands including build, watch, clean, and serve options with examples and use cases.",
    "content": "Commands Reference MarkStack provides a set of npm scripts for building, developing, and previewing your site. This page documents each command in detail. Available Commands Command Purpose npm run build Build the site for production npm run watch Build and rebuild on file changes npm run clean Delete the dist folder npx serve dist Preview the built site locally npm run build The build command generates your complete site in the dist/ folder. Usage npm run build What It Does Clears any existing dist/ folder Copies all files from static/ to dist/ Builds the URL map from content titles Processes every markdown file in content/ Generates HTML pages using the template Creates the homepage and 404 page Generates search-index.json for search functionality Output ğŸ”¨ Building MarkStack... âœ“ Copied static files âœ“ Generated: /getting-started/ âœ“ Generated: /getting-started/installation/ âœ“ Generated: /getting-started/quickstart/ âœ“ Generated: /authoring/ âœ“ Generated: /authoring/markdown-features/ ... âœ“ Generated: / (homepage) âœ“ Generated: /404.html âœ“ Generated: /search-index.json (42 pages) âœ… Build complete in 127ms ğŸ“ Output: C:\\Users\\...\\MarkStack\\dist When to Use Before deploying to production After making content changes you want to preview To generate a clean build for testing npm run watch The watch command builds the site and then watches for file changes, automatically rebuilding when you save. Usage npm run watch What It Does Performs an initial build (same as npm run build ) Watches the following directories for changes: content/ - Markdown files static/ - CSS, JavaScript, images templates/ - HTML templates When a file changes, rebuilds the entire site Output ğŸ‘€ Watching for changes... ğŸ”¨ Building MarkStack... âœ“ Copied static files âœ“ Generated: /getting-started/ ... âœ… Build complete in 127ms ğŸ“ Changed: content\\authoring\\examples.md ğŸ”¨ Building MarkStack... ... âœ… Build complete in 132ms When to Use During content development When writing or editing documentation When adjusting styles or templates TIP Run npm run watch in one terminal and npx serve dist in another. As you save files, the site rebuilds automatically and you can refresh your browser to see changes. File Watching Details The watcher uses chokidar, a reliable cross-platform file watching library. It detects: File modifications (content changes) File additions (new pages) File deletions (removed pages) Each detected change triggers a full rebuild to ensure navigation and search index stay current. npm run clean The clean command removes the dist/ folder entirely. Usage npm run clean What It Does Deletes the dist/ directory and all its contents recursively. Output The command runs silently. To verify: npm run clean ls dist Should show \"dist does not exist\" or similar error When to Use Before a fresh build to ensure no stale files When troubleshooting build issues To reduce folder size before archiving the project Note: The build command already clears dist/ before building, so clean is optional in most workflows. npx serve dist The serve command runs a local HTTP server to preview your built site. Usage npx serve dist What It Does Starts a static file server using the serve package, hosting the contents of dist/ at http://localhost:3000 . Output â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”‚ Serving! â”‚ â”‚ â”‚ â”‚ - Local: http://localhost:3000 â”‚ â”‚ - Network: http://192.168.1.50:3000 â”‚ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ Options Specify a different port: npx serve dist -l 8080 Disable directory listing: npx serve dist --no-clipboard When to Use To preview the site before deployment To test on mobile devices (use the network URL) To verify the production build works correctly Alternative: Python Server If you have Python installed: cd dist python -m http.server 3000 Alternative: VS Code Live Server If you use VS Code, you can right-click dist/index.html and select â€œOpen with Live Serverâ€ (requires the Live Server extension). Combined Development Workflow For active development, use two terminal windows: Terminal 1: Watch Mode npm run watch Keep this running. It rebuilds automatically when you save files. Terminal 2: Local Server npx serve dist Open http://localhost:3000 in your browser. Refresh after saves to see changes. Workflow Steps Start watch mode in terminal 1 Start server in terminal 2 Open browser to localhost:3000 Edit markdown files in your editor Save the file Wait for rebuild message in terminal 1 Refresh browser to see changes Repeat steps 4-7 Build Script Internals The build process is handled by build.js , a single-file static site generator. Key stages: URL Map Generation Scans all content and builds a mapping from file paths to URL slugs based on page titles. Markdown Processing Uses markdown-it with plugins: markdown-it-anchor for heading links markdown-it-footnote for footnotes markdown-it-task-lists for checkboxes Custom plugin for GitHub-style alerts Navigation Building Builds the sidebar tree and breadcrumbs by walking the directory structure. Template Application Replaces placeholders in templates/base.html with generated content. Search Index Creates a JSON file with page titles, URLs, and plain-text content for client-side search. Troubleshooting Build Fails with â€œCannot find moduleâ€ Dependencies are not installed: npm install npm run build Watch Mode Does Not Detect Changes Chokidar may have issues with certain file systems. Try: Stop watch mode (Ctrl+C) npm run build Manual build Port Already in Use If port 3000 is taken: npx serve dist -l 8080 Or find and stop the process using port 3000. Changes Not Appearing Verify the file saved (check editor) Check terminal for rebuild confirmation Hard refresh browser (Ctrl+Shift+R or Cmd+Shift+R) Clear browser cache NOTE The build script clears and regenerates dist/ on every build. Any manual changes to files in dist/ will be overwritten."
  },
  {
    "title": "Deployment Guide",
    "url": "/build-and-deploy/deployment-guide",
    "description": "Deploy your MarkStack site to Netlify, Vercel, GitHub Pages, Cloudflare Pages, or self-host with nginx and Apache.",
    "content": "Deployment Guide MarkStack generates a static site that can be deployed anywhere static files are served. This guide covers deployment to popular platforms and self-hosting options. Pre-Deployment Checklist Before deploying, verify your site is ready: Site builds without errors: npm run build All pages render correctly in local preview Search functionality works Navigation is correct siteconfig.json has the correct siteUrl for production Images and links work Update Site URL Edit siteconfig.json and set the production URL: { \"siteUrl\" : \"https://docs.yoursite.com\" } This URL is used in OpenGraph meta tags for social sharing. Rebuild after changing. Netlify Netlify offers free hosting for static sites with automatic deployments from Git. Deploy from Git (Recommended) Push your project to GitHub, GitLab, or Bitbucket Sign in to Netlify Click â€œAdd new siteâ€ and select â€œImport an existing projectâ€ Connect your Git provider and select your repository Configure build settings: Build command : npm run build Publish directory : dist Click â€œDeploy siteâ€ Netlify will build and deploy automatically on every push to your main branch. Create netlify.toml For consistent builds, add a netlify.toml file to your project root: [build] command = \"npm run build\" publish = \"dist\" [build.environment] NODEVERSION = \"20\" Redirect rules for clean URLs [[redirects]] from = \"/\" to = \"/404.html\" status = 404 Manual Deploy with CLI For one-time deploys without Git: Install Netlify CLI npm install -g netlify-cli Login to Netlify netlify login Build your site npm run build Deploy to production netlify deploy --prod -- dir =dist Custom Domain Go to Site settings in Netlify Click â€œDomain managementâ€ Add your custom domain Follow DNS configuration instructions Enable HTTPS (automatic with Letâ€™s Encrypt) Vercel Vercel provides fast global hosting with Git integration. Deploy from Git Push your project to GitHub, GitLab, or Bitbucket Sign in to Vercel Click â€œAdd New Projectâ€ Import your repository Configure settings: Framework Preset : Other Build Command : npm run build Output Directory : dist Click â€œDeployâ€ Create vercel.json Add a vercel.json file for configuration: { \"buildCommand\" : \"npm run build\" , \"outputDirectory\" : \"dist\" , \"routes\" : [ { \"handle\" : \"filesystem\" } , { \"src\" : \"/(.)\" , \"dest\" : \"/404.html\" , \"status\" : 404 } ] } Manual Deploy with CLI Install Vercel CLI npm install -g vercel Login vercel login Build npm run build Deploy (follow prompts) vercel --prod GitHub Pages GitHub Pages hosts static sites directly from your repository. Using GitHub Actions (Recommended) Create .github/workflows/deploy.yml : name: Deploy to GitHub Pages on: push: branches: [ main ] workflowdispatch: permissions: contents: read pages: write id-token: write concurrency: group: \"pages\" cancel-in-progress: true jobs: build: runs-on: ubuntu-latest steps: name: Checkout uses: actions/checkout@v4 name: Setup Node uses: actions/setup-node@v4 with: node-version: &x27;20&x27; cache: &x27;npm&x27; name: Install dependencies run: npm ci name: Build run: npm run build name: Upload artifact uses: actions/upload-pages-artifact@v3 with: path: ./dist deploy: needs: build runs-on: ubuntu-latest environment: name: github-pages url: ${{ steps.deployment.outputs.pageurl }} steps: name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v4 In your repository settings, go to Pages Under â€œBuild and deploymentâ€, select â€œGitHub Actionsâ€ Push to main branch to trigger deployment GitHub Pages URL Your site will be available at: Organization/user site: https://username.github.io/ Project site: https://username.github.io/repository-name/ For project sites, you may need to update base URLs in your config. Cloudflare Pages Cloudflare Pages offers fast global hosting with Git integration. Deploy from Git Sign in to Cloudflare Dashboard Go to Workers and Pages Click â€œCreate applicationâ€ then â€œPagesâ€ Connect to Git and select your repository Configure build settings: Framework preset : None Build command : npm run build Build output directory : dist Click â€œSave and Deployâ€ Create wrangler.toml For Cloudflare-specific configuration: name = \"your-site-name\" pagesbuildoutputdir = \"dist\" Self-Hosting For complete control, host the static files yourself. nginx Configuration server { listen 80 ; servername docs.yoursite.com; Redirect to HTTPS return 301 https:// $servername $requesturi ; } server { listen 443 ssl http2; servername docs.yoursite.com; SSL certificates (use Let&x27;s Encrypt) sslcertificate /etc/letsencrypt/live/docs.yoursite.com/fullchain.pem; sslcertificatekey /etc/letsencrypt/live/docs.yoursite.com/privkey.pem; root /var/www/docs.yoursite.com; index index.html; Clean URLs location / { tryfiles $uri $uri / $uri /index.html = 404 ; } Custom 404 page errorpage 404 / 404 .html; Cache static assets location ~ \\.(css|js|svg|png|jpg|jpeg|gif|ico|woff2)$ { expires 1y ; addheader Cache-Control \"public, immutable\" ; } Security headers addheader X-Content-Type-Options nosniff; addheader X-Frame-Options DENY; addheader X-XSS-Protection \"1; mode=block\" ; } Apache Configuration Create a .htaccess file in your document root: Enable rewrite engine RewriteEngine On Redirect HTTP to HTTPS RewriteCond %{HTTPS} off RewriteRule ^ https:// %{HTTPHOST} %{REQUESTURI} [L,R=301] Clean URLs RewriteCond %{REQUESTFILENAME} !-f RewriteCond %{REQUESTFILENAME} !-d RewriteCond %{REQUESTFILENAME} /index.html -f RewriteRule ^(.)$ $ 1 /index.html [L] Custom 404 ErrorDocument 404 / 404 .html Cache static assets <IfModule modexpires.c> ExpiresActive On ExpiresByType text/css \"access plus 1 year\" ExpiresByType application/javascript \"access plus 1 year\" ExpiresByType image/svg+xml \"access plus 1 year\" ExpiresByType image/png \"access plus 1 year\" ExpiresByType image/jpeg \"access plus 1 year\" </IfModule> Security headers <IfModule modheaders.c> Header set X-Content-Type-Options \"nosniff\" Header set X-Frame-Options \"DENY\" Header set X-XSS-Protection \"1; mode=block\" </IfModule> Caddy Configuration Caddy provides automatic HTTPS: docs.yoursite.com { root /var/www/docs.yoursite.com fileserver Clean URLs tryfiles {path} {path}/ {path}/index.html Custom 404 handleerrors { rewrite /404.html fileserver } Cache headers @static { path .css .js .svg .png .jpg .jpeg .gif .woff2 } header @static Cache-Control \"public, max-age=31536000, immutable\" } Deploying to Self-Hosted Server Build locally npm run build Copy to server (example using rsync) rsync -avz --delete dist/ user@server:/var/www/docs.yoursite.com/ Or using SCP scp -r dist/ user@server:/var/www/docs.yoursite.com/ Docker Deployment Create Dockerfile FROM node: 20 -alpine AS builder WORKDIR /app COPY package.json ./ RUN npm ci COPY . . RUN npm run build FROM nginx:alpine COPY --from=builder /app/dist /usr/share/nginx/html COPY nginx.conf /etc/nginx/conf.d/default.conf EXPOSE 80 CMD [ \"nginx\" , \"-g\" , \"daemon off;\" ] Create nginx.conf server { listen 80 ; root /usr/share/nginx/html; index index.html; location / { tryfiles $uri $uri / $uri /index.html = 404 ; } errorpage 404 / 404 .html; } Build and Run docker build -t markstack-docs . docker run -p 8080:80 markstack-docs CDN Configuration For better performance, serve assets through a CDN: Recommended CDN Settings Asset Type Cache Duration HTML files 1 hour or less CSS files 1 year JavaScript 1 year Images 1 year Fonts 1 year Cache Invalidation Since MarkStack rebuilds everything on each build, use cache-busting only for HTML. CSS and JS can be cached long-term because they do not change frequently. Performance Optimization Compression Enable gzip or brotli compression on your server: nginx: gzip on ; gziptypes text/html text/css application/javascript application/json image/svg+xml; Apache: <IfModule moddeflate.c> AddOutputFilterByType DEFLATE text/html text/css application/javascript application/json image/svg+xml </IfModule> HTTP/2 Enable HTTP/2 for parallel asset loading: Netlify, Vercel, Cloudflare: Enabled by default nginx: listen 443 ssl http2; Apache: Protocols h2 http/1.1 Post-Deployment Verification After deploying, verify: Homepage loads correctly Navigation works on all pages Search returns results Theme toggle works Code blocks display correctly External links open correctly 404 page shows for invalid URLs HTTPS is working (no mixed content warnings) TIP Use browser developer tools to check for console errors and network issues after deployment."
  },
  {
    "title": "Build and Deploy",
    "url": "/build-and-deploy/",
    "description": "Learn how to build, preview, and deploy your MarkStack site to production using various hosting platforms and CI/CD pipelines.",
    "content": "Build and Deploy This section covers everything you need to know about building your MarkStack site for development and production, deploying to hosting platforms, and setting up automated deployments. Build Overview MarkStack generates a static site from your markdown content. The build process: Reads all markdown files from content/ Parses frontmatter and converts markdown to HTML Generates navigation (sidebar and breadcrumbs) Applies the HTML template Creates a search index for client-side search Copies static assets Outputs everything to dist/ The result is a folder of static HTML, CSS, JavaScript, and assets that can be served by any web server. What This Section Covers Commands Reference The Commands Reference covers all available npm scripts: Building for production Running a development server with file watching Cleaning the build output Previewing the built site locally Deployment Guide The Deployment Guide explains how to deploy your site: Preparing your site for production Deploying to popular platforms (Netlify, Vercel, GitHub Pages, Cloudflare Pages) Self-hosting with nginx or Apache Custom domain configuration CI/CD Integration The CI/CD Integration guide covers automated deployments: GitHub Actions workflow setup GitLab CI configuration Automated builds on push Preview deployments for pull requests Quick Reference Development Workflow Make changes to content Build and watch for changes npm run watch In another terminal, serve the site npx serve dist Preview at http://localhost:3000 Production Build Clean previous build npm run clean Build for production npm run build The dist/ folder is ready to deploy Deployment Commands Most platforms deploy automatically when you push to your repository. For manual deployment: Netlify CLI npx netlify-cli deploy --prod -- dir =dist Vercel CLI npx vercel --prod GitHub Pages (after setting up workflow) git push origin main Build Performance MarkStack builds are fast. Typical build times: Site Size Build Time 10 pages ~50ms 50 pages ~100ms 200 pages ~300ms 500 pages ~600ms The build script processes files in a single pass with no external API calls, keeping builds consistently quick. Static Output The dist/ folder contains: dist/ index.html Homepage 404.html Error page search-index.json Search data css/ main.css Site styles hljs-theme.css Code highlighting js/ app.js Interactive features svg/ logo.svg Site logo [page-slug]/ index.html Each page in its own folder Every page is output as [slug]/index.html for clean URLs without file extensions. Hosting Requirements MarkStack sites are purely static and work on any host that serves HTML files. Requirements: Ability to serve static files Support for clean URLs (rewriting /page/ to /page/index.html ) HTTPS support (recommended for security) No server-side processing, databases, or special runtimes are required. TIP If you are unsure which hosting platform to choose, Netlify and Vercel both offer generous free tiers and automatic deployments from Git repositories."
  },
  {
    "title": "Homepage Content",
    "url": "/configuration/homepage-content",
    "description": "Learn how to customize your MarkStack homepage with hero sections, custom markdown content, and different layout approaches.",
    "content": "Homepage Content The homepage is the first thing visitors see when they arrive at your documentation site. MarkStack gives you flexibility in how you design this experience, combining configuration settings with optional markdown content. This guide explains how the homepage works and the different approaches you can take to create an effective landing page. How the Homepage Works The homepage is generated from two sources: siteconfig.json : Controls the hero section (title, subtitle, visibility) content/index.md : Optional markdown content rendered below the hero When someone visits the root URL of your site ( / ), MarkStack combines these sources to generate the homepage. Homepage Generation Process flowchart TD A[siteconfig.json] --> B[Hero Section optional] C[content/index.md] --> D[Markdown Body optional] B --> E[Homepage dist/index.html] D --> E The Hero Section The hero section is a prominent area at the top of the homepage displaying your site title and subtitle. Enabling the Hero The hero appears when showHero is true (the default): { \"siteTitle\" : \"My Documentation\" , \"siteSubtitle\" : \"Complete guides and API reference\" , \"showHero\" : true } This produces a hero section with: A large heading showing siteTitle A smaller paragraph showing siteSubtitle Styled background that matches your theme Disabling the Hero Set showHero to false for a more compact homepage: { \"showHero\" : false } Without the hero, the homepage displays: The site header (same as all pages) Content from content/index.md (if present) The sidebar navigation When to Use Each Approach Use Hero Best For Yes Product documentation, marketing-oriented sites, sites needing strong branding No Technical references, internal documentation, compact utility-focused sites Adding Custom Homepage Content Create content/index.md to add markdown content to your homepage. This content appears below the hero (or at the top if the hero is disabled). Basic Homepage Content --- description: Welcome to our documentation. Find guides, tutorials, and references. --- Welcome This documentation helps you get started quickly and find answers to your questions. Popular Topics Getting Started for new users API Reference for developers FAQ for common questions Homepage with Feature Highlights --- description: Official documentation for ExampleApp with guides, tutorials, and API reference. --- Quick Links | I want to... | Go to... | |--------------|----------| | Install the software | Installation Guide | | Learn the basics | Quick Start Tutorial | | Integrate via API | API Reference | | Troubleshoot issues | Common Problems | What&x27;s New v2.1 Released : New dashboard features and performance improvements Updated API docs : All endpoints now include example requests Video tutorials : Watch our new getting started series Need Help? Check the FAQ or contact support . Homepage with Callouts --- description: Learn how to use AwesomeLib with comprehensive documentation and examples. --- > [!TIP] > New to AwesomeLib? Start with the 5-minute quickstart . Documentation Sections For Beginners The Getting Started section walks you through installation, basic concepts, and your first project. For Developers The API Reference provides complete documentation for every function, class, and configuration option. For Operations The Deployment Guide covers production configuration, monitoring, and scaling. > [!NOTE] > This documentation covers version 2.x. For version 1.x documentation, visit v1.example.com . Homepage Without content/index.md If you do not create content/index.md , the homepage shows: The hero section (if enabled) The sidebar navigation No main content area This works for very simple sites, but most documentation benefits from at least a brief introduction and navigation guidance on the homepage. Combining Hero and Content The most common approach uses both the hero and custom content: siteconfig.json: { \"siteTitle\" : \"ExampleApp Documentation\" , \"siteSubtitle\" : \"Everything you need to build with ExampleApp\" , \"showHero\" : true } content/index.md: --- description: Official ExampleApp documentation with tutorials, guides, and API reference. --- Getting Started New to ExampleApp? Follow our step-by-step guide to install the software and build your first project. Start the tutorial Browse by Topic Guides - Task-oriented tutorials Reference - API and configuration documentation Examples - Sample code and projects This creates a homepage with: A hero section with the title â€œExampleApp Documentationâ€ and subtitle A â€œGetting Startedâ€ section with a link to the tutorial A topic list for easy navigation Content-Only Homepage For a more compact, content-focused homepage: siteconfig.json: { \"siteTitle\" : \"Technical Reference\" , \"showHero\" : false } content/index.md: --- description: Technical reference documentation and specifications. --- Technical Reference This documentation provides specifications, API details, and implementation guidance. Sections | Section | Contents | |---------|----------| | Specifications | Protocol specifications and data formats | | API | REST API endpoint documentation | | SDKs | Client library documentation | | Examples | Code samples and reference implementations | Recent Updates Specification v3.2 published with new authentication flow Python SDK updated to support async operations New examples for webhook integration This homepage immediately presents content without the visual prominence of a hero section. Homepage Description The description in content/index.md frontmatter provides the meta description for your homepage: --- description: Official documentation for ExampleApp including installation guides, tutorials, and complete API reference. --- This description appears in: Search engine results for your homepage Social media previews when someone shares your homepage URL The HTML <meta name=\"description\"> tag Write a compelling description that tells visitors what your documentation covers. Since the homepage often receives the most search traffic, its description is especially important for SEO. If you omit the description in content/index.md , MarkStack uses defaultDescription from siteconfig.json . Layout Considerations When designing your homepage, consider: Above the Fold The content visible without scrolling should: Identify what the documentation covers Help visitors navigate to common destinations Work for both new and returning visitors Information Hierarchy Structure content from general to specific: Site identification (hero or title) Primary navigation paths Whatâ€™s new or highlighted content Additional resources Mobile Responsiveness The homepage uses the same responsive design as all pages: On mobile, the sidebar collapses Content stacks vertically Tables may scroll horizontally Keep homepage content scannable and avoid very wide tables. Testing Your Homepage After configuring your homepage: Run npm run build to generate the site Run npm run serve to start the preview server Open http://localhost:3000 in your browser Verify the hero appears (or not) as expected Check that custom content renders correctly Test navigation links View the page source to verify meta tags TIP Test your homepage on both desktop and mobile screen sizes. The sidebar collapses on mobile, so your homepage content becomes the primary navigation."
  },
  {
    "title": "Site Config",
    "url": "/configuration/site-config",
    "description": "Complete reference for siteconfig.json, covering every configuration field with examples, default values, and best practices for SEO and branding.",
    "content": "Site Config The siteconfig.json file controls the identity and behavior of your MarkStack site. This reference documents every available field, explains how each one affects your site, and provides guidance on choosing the right values. File Location and Format The configuration file must be named siteconfig.json and placed in your project root: markstack/ â”œâ”€â”€ siteconfig.json <-- Configuration file â”œâ”€â”€ build.js â”œâ”€â”€ content/ â””â”€â”€ ... The file uses standard JSON format: { \"siteTitle\" : \"My Documentation\" , \"headerTitle\" : \"MyDocs\" , \"siteSubtitle\" : \"Everything you need to know\" , \"siteUrl\" : \"https://docs.example.com\" , \"defaultDescription\" : \"Official documentation and guides\" , \"showHero\" : true , \"copyrightText\" : \"Â© 2024 My Company. All rights reserved.\" } Configuration Fields siteTitle The full name of your site. This is the primary title used throughout your documentation. Property Value Type String Required No Default \"Knowledge Base\" Where it appears: Browser tab titles (format: â€œPage Title | Site Titleâ€) The hero section on the homepage (when enabled) Open Graph meta tags for social sharing Example: { \"siteTitle\" : \"Acme Platform Documentation\" } Best practices: Keep it under 60 characters so it displays fully in search results Include your product or company name for brand recognition Make it descriptive enough that readers know what the site covers headerTitle A shorter version of your site title displayed in the site header. Property Value Type String Required No Default Uses siteTitle value Where it appears: The site header next to the logo Displayed on every page Example: { \"siteTitle\" : \"Acme Platform Documentation\" , \"headerTitle\" : \"Acme Docs\" } When to use: Use headerTitle when your siteTitle is too long to fit comfortably in the header. A long title like â€œAcme Platform Complete Documentation and API Referenceâ€ looks better shortened to â€œAcme Docsâ€ in the header while keeping the full title for browser tabs and search results. If headerTitle is not set, the header displays siteTitle . siteSubtitle A tagline or description displayed below the main title in the hero section. Property Value Type String Required No Default \"\" (empty string) Where it appears: Below the title in the homepage hero section Only visible when showHero is true Example: { \"siteTitle\" : \"Acme Platform Documentation\" , \"siteSubtitle\" : \"Guides, tutorials, and API reference for developers\" } Best practices: Keep it to one sentence Explain what readers will find or what problem the documentation solves Leave empty (or omit) if you prefer a minimal hero siteUrl The full URL where your site will be hosted in production. Property Value Type String Required No Default \"\" (empty string) Where it appears: Canonical URL meta tags Open Graph og:url meta tags Generates full URLs in sitemap.xml if you add one Example: { \"siteUrl\" : \"https://docs.acme.com\" } Important notes: Include the protocol ( https:// ) Do not include a trailing slash Use your production URL, not localhost This value is used at build time, so changes require a rebuild Why it matters: Search engines use the canonical URL to understand the authoritative location of your content. Social media platforms use og:url when your pages are shared. Setting this correctly improves SEO and ensures shared links work properly. defaultDescription A fallback description used when pages do not specify their own description in frontmatter. Property Value Type String Required No Default \"Documentation and knowledge base\" Where it appears: HTML <meta name=\"description\"> tag on pages without frontmatter descriptions Open Graph og:description tag on pages without frontmatter descriptions Search result snippets for pages without descriptions Example: { \"defaultDescription\" : \"Official documentation for Acme Platform including guides, tutorials, and API reference.\" } Best practices: Write 150 to 160 characters (search engines truncate longer descriptions) Summarize what readers will find in your documentation Use complete sentences with natural language Include important keywords naturally Add specific descriptions to important pages rather than relying on this default showHero Controls whether the hero section appears on the homepage. Property Value Type Boolean Required No Default true What the hero section includes: siteTitle as a large heading siteSubtitle below the title Styled background section at the top of the homepage Example (hero enabled): { \"siteTitle\" : \"Acme Documentation\" , \"siteSubtitle\" : \"Everything you need to build with Acme\" , \"showHero\" : true } Example (hero disabled): { \"showHero\" : false } When to disable the hero: You want a compact homepage that jumps straight to content Your homepage content in content/_index.md serves as its own introduction You prefer a more utilitarian, content-focused design copyrightText Text displayed in the footer of every page. Property Value Type String Required No Default \"\" (empty string) Where it appears: The site footer on all pages Example: { \"copyrightText\" : \"Â© 2024 Acme Inc. All rights reserved.\" } Best practices: Include the copyright symbol (Â©), year, and your company or name Keep it brief since footer space is limited Update the year when it changes (or use a build script to automate this) Complete Configuration Examples Minimal Configuration For a simple documentation site with defaults: { \"siteTitle\" : \"Project Docs\" , \"siteUrl\" : \"https://docs.example.com\" } Full Configuration Using all available options: { \"siteTitle\" : \"Acme Platform Documentation\" , \"headerTitle\" : \"Acme Docs\" , \"siteSubtitle\" : \"Comprehensive guides and API reference for developers\" , \"siteUrl\" : \"https://docs.acme.com\" , \"defaultDescription\" : \"Official documentation for Acme Platform. Learn how to integrate, customize, and deploy.\" , \"showHero\" : true , \"copyrightText\" : \"Â© 2024 Acme Inc. Licensed under MIT.\" } Compact Style (No Hero) For documentation that focuses on content: { \"siteTitle\" : \"Technical Reference\" , \"headerTitle\" : \"TechRef\" , \"siteUrl\" : \"https://ref.example.com\" , \"defaultDescription\" : \"Technical reference documentation and specifications.\" , \"showHero\" : false , \"copyrightText\" : \"Â© 2024 Example Corp.\" } Open Source Project For an open source projectâ€™s documentation: { \"siteTitle\" : \"AwesomeLib Documentation\" , \"headerTitle\" : \"AwesomeLib\" , \"siteSubtitle\" : \"A powerful library for doing awesome things\" , \"siteUrl\" : \"https://awesomelib.github.io\" , \"defaultDescription\" : \"Documentation for AwesomeLib, the open source library for awesome things.\" , \"showHero\" : true , \"copyrightText\" : \"Licensed under Apache 2.0. Made with MarkStack.\" } SEO Considerations Proper configuration improves how your documentation appears in search engines: Page Titles Search results display page titles in the format â€œPage Title | Site Titleâ€. Keep siteTitle concise so page titles are not truncated. A title like â€œInstallation Guide | Acme Docsâ€ is better than â€œInstallation Guide | Acme Platform Complete Documentation and Referenceâ€. Meta Descriptions The defaultDescription appears in search results for pages without their own description. While it is a useful fallback, add specific description values to important pages for better search result snippets. Canonical URLs Setting siteUrl correctly generates proper canonical URL tags. This tells search engines the authoritative URL for each page, which: Prevents duplicate content issues Consolidates ranking signals Ensures the correct URL appears in search results Social Sharing When someone shares your documentation on social media, the platform reads Open Graph meta tags: og:title comes from the page title og:description comes from page description or defaultDescription og:url comes from siteUrl combined with the page path Example of how a shared page appears: Acme Platform Documentation docs.acme.com Official documentation for Acme Platform. Learn how to integrate, customize, and deploy. TIP After changing siteconfig.json , test social sharing by pasting a page URL into the Facebook Sharing Debugger or Twitter Card Validator . These tools show exactly what social platforms see. Validation MarkStack does not validate siteconfig.json strictly. If the file is missing or contains invalid JSON, the build uses default values and prints a warning. If a field is missing, its default value applies. To verify your configuration: Run npm run build Open dist/index.html in a browser View page source and check meta tags Verify the header shows your expected title Check the footer for copyright text NOTE JSON does not allow trailing commas. If you see parse errors, check for commas after the last item in objects or arrays."
  },
  {
    "title": "Configuration",
    "url": "/configuration/",
    "description": "Learn how to configure your MarkStack site using siteconfig.json for site identity, metadata, and homepage behavior.",
    "content": "Configuration MarkStack keeps configuration simple. A single JSON file controls all site-wide settings, from the site title to homepage behavior. This section explains every configuration option and how to use them effectively. Configuration Overview All site configuration lives in siteconfig.json at your project root. This file controls: Site identity : The name and branding that appears throughout your site Metadata : Default descriptions and URLs used in search engines and social sharing Homepage behavior : Whether to show a hero section and what content to display There is no complex configuration file format to learn. JSON is straightforward, and MarkStack uses sensible defaults for anything you do not specify. What This Section Covers Site Config The Site Config guide provides a complete reference for siteconfig.json : Every available field with its purpose How each field affects your site Example configurations for different use cases Tips for SEO and social sharing optimization This is the essential reference when setting up a new MarkStack site or adjusting existing settings. Homepage Content The Homepage Content guide explains how to customize your homepage: How the hero section works and when to use it Adding custom markdown content below the hero Creating a homepage without the hero section Balancing site configuration with content The homepage combines settings from siteconfig.json with optional content from content/_index.md , giving you flexibility in how you welcome visitors. Quick Start Configuration If you are setting up MarkStack for the first time, here is a minimal configuration to get started: { \"siteTitle\" : \"My Documentation\" , \"headerTitle\" : \"MyDocs\" , \"siteUrl\" : \"https://docs.example.com\" } Save this as siteconfig.json in your project root, then run npm run build . You now have a configured site with your branding. Configuration Best Practices Practice Reason Set siteUrl to your production URL Ensures Open Graph tags and canonical URLs are correct Keep siteTitle concise Appears in browser tabs and search results Write a meaningful defaultDescription Used when pages lack their own description Decide on hero visibility early Affects how you structure homepage content When to Rebuild After changing siteconfig.json , run npm run build (or let npm run watch rebuild automatically). Configuration changes apply to all pages, so every page regenerates with the new values. TIP Keep npm run watch running while adjusting configuration. You can edit siteconfig.json , save it, and immediately see the results in your browser preview."
  },
  {
    "title": "Templates",
    "url": "/customization/templates",
    "description": "Understand and customize the MarkStack HTML template, add analytics scripts, modify page structure, and extend the template system.",
    "content": "Templates MarkStack uses a single HTML template file that defines the structure of every page. This guide explains how the template works and how to customize it safely. Template Location The template file is located at: templates/base.html Every page on your site is generated from this template. The build script replaces placeholder tokens with page-specific content during the build process. Understanding Placeholders The template uses double-brace syntax for placeholders: < title > {{title}} | {{siteTitle}} </ title > During the build, {{title}} is replaced with the pageâ€™s title and {{siteTitle}} with the value from siteconfig.json . Available Placeholders Here is the complete list of placeholders you can use in the template: Placeholder Source Description {{title}} Frontmatter or filename The current pageâ€™s title {{siteTitle}} siteconfig.json headerTitle Site name shown in header {{description}} Frontmatter or default Page meta description {{url}} Generated from siteUrl + path Full URL for OpenGraph {{content}} Rendered markdown The pageâ€™s HTML content {{sidebar}} Generated navigation Sidebar HTML tree {{breadcrumbs}} Generated navigation Breadcrumb HTML {{pageClass}} Build script Additional page classes (e.g., homepage) {{copyrightText}} siteconfig.json Footer copyright text Where Placeholders Are Used Looking at the default template: <!-- In the head --> < meta name = \"description\" content = \"{{description}}\" > < meta property = \"og:title\" content = \"{{title}} | {{siteTitle}}\" > < title > {{title}} | {{siteTitle}} </ title > <!-- In the header --> < span class = \"logo-text\" > {{siteTitle}} </ span > <!-- In the main content --> {{breadcrumbs}} {{sidebar}} {{content}} <!-- In the footer --> < p class = \"copyright\" > {{copyrightText}} </ p > Template Structure The template is organized into clear sections: Head Section Contains meta tags, fonts, styles, and scripts that run before page render: < head > < meta charset = \"UTF-8\" > <!-- Theme initialization (prevents flash of wrong theme) --> < script > ( function ( ) { const theme = localStorage . getItem ( &x27;theme&x27; ) || &x27;dark&x27; ; document . documentElement . setAttribute ( &x27;data-theme&x27; , theme); })(); </ script > <!-- Sidebar state initialization --> < script > ( function ( ) { const savedState = localStorage . getItem ( &x27;sidebar-state&x27; ); if (savedState === &x27;collapsed&x27; ) { document . documentElement . classList . add ( &x27;sidebar-collapsed&x27; ); } })(); </ script > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta name = \"description\" content = \"{{description}}\" > <!-- Fonts --> < link rel = \"preconnect\" href = \"https://fonts.googleapis.com\" > < link href = \"https://fonts.googleapis.com/css2?family=...\" rel = \"stylesheet\" > <!-- OpenGraph tags for social sharing --> < meta property = \"og:title\" content = \"{{title}} | {{siteTitle}}\" > < meta property = \"og:description\" content = \"{{description}}\" > < title > {{title}} | {{siteTitle}} </ title > <!-- Stylesheets --> < link rel = \"stylesheet\" href = \"/css/main.css\" > < link rel = \"stylesheet\" href = \"/css/hljs-theme.css\" > <!-- Favicon --> < link rel = \"icon\" href = \"/svg/logo.svg\" type = \"image/svg+xml\" > </ head > Header Section Contains the site logo, search, and theme toggle: < header class = \"site-header\" > < div class = \"header-container\" > <!-- Logo --> < a href = \"/\" class = \"site-logo\" > < img src = \"/svg/logo.svg\" alt = \"Logo\" class = \"logo-icon\" > < span class = \"logo-text\" > {{siteTitle}} </ span > </ a > <!-- Search --> < div class = \"header-search\" > <!-- Search input and results --> </ div > <!-- Theme toggle --> < div class = \"header-actions\" > < button id = \"theme-toggle\" class = \"theme-toggle\" > <!-- Sun and moon icons --> </ button > </ div > </ div > </ header > Breadcrumb Bar Shows the navigation path to the current page: < div class = \"breadcrumb-bar\" > < div class = \"breadcrumb-container\" > {{breadcrumbs}} </ div > </ div > Main Layout Contains the sidebar and content area: < div class = \"main-layout{{pageClass}}\" > < aside class = \"sidebar\" > < nav class = \"sidebar-nav\" > {{sidebar}} </ nav > </ aside > < main class = \"content\" > < article class = \"article\" > {{content}} </ article > </ main > </ div > Footer Section Contains site footer and copyright: < footer class = \"site-footer\" > < div class = \"footer-container\" > < p > Built with MarkStack </ p > < p class = \"copyright\" > {{copyrightText}} </ p > </ div > </ footer > Scripts JavaScript loaded at the end of the body: < script src = \"/js/app.js\" > </ script > </ body > </ html > Safe Template Modifications Adding Analytics To add analytics (Google Analytics, Plausible, Fathom, etc.), insert the script before the closing </head> tag: <!-- Analytics --> < script async src = \"https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX\" > </ script > < script > window . dataLayer = window . dataLayer || []; function gtag ( ){dataLayer. push ( arguments );} gtag ( &x27;js&x27; , new Date ()); gtag ( &x27;config&x27; , &x27;G-XXXXXXXXXX&x27; ); </ script > </ head > For privacy-focused analytics like Plausible: < script defer data-domain = \"yourdomain.com\" src = \"https://plausible.io/js/script.js\" > </ script > </ head > Adding Custom Meta Tags Add meta tags in the <head> section: <!-- Twitter card --> < meta name = \"twitter:card\" content = \"summarylargeimage\" > < meta name = \"twitter:site\" content = \"@yourhandle\" > <!-- Author information --> < meta name = \"author\" content = \"Your Name\" > <!-- Robots directives --> < meta name = \"robots\" content = \"index, follow\" > <!-- Canonical URL (uses the page URL) --> < link rel = \"canonical\" href = \"{{url}}\" > Adding External Stylesheets Add CSS links after the existing stylesheets: < link rel = \"stylesheet\" href = \"/css/main.css\" > < link rel = \"stylesheet\" href = \"/css/hljs-theme.css\" > <!-- Your custom stylesheet --> < link rel = \"stylesheet\" href = \"/css/custom.css\" > Create static/css/custom.css with your additional styles. Adding JavaScript Libraries Add scripts before the closing </body> tag: < script src = \"/js/app.js\" > </ script > <!-- Additional libraries --> < script src = \"https://cdn.example.com/library.js\" > </ script > < script src = \"/js/custom.js\" > </ script > </ body > Create static/js/custom.js with your custom code. Modifying Page Structure Adding a Table of Contents Placeholder If you want to add a table of contents area, you could add a placeholder: < main class = \"content\" > < article class = \"article\" > {{content}} </ article > < aside class = \"toc\" > <!-- Table of contents would go here --> </ aside > </ main > Note: You would need to modify build.js to generate and inject table of contents content. Adding a Reading Progress Bar Add this after the opening <body> tag: < div class = \"reading-progress\" > < div class = \"reading-progress-bar\" id = \"progress-bar\" > </ div > </ div > Then add JavaScript in a custom script file: window . addEventListener ( &x27;scroll&x27; , function ( ) { const article = document . querySelector ( &x27;.article&x27; ); if (!article) return ; const rect = article. getBoundingClientRect (); const progress = Math . min ( 100 , Math . max ( 0 , ((-rect. top ) / (rect. height - window . innerHeight )) * 100 )); document . getElementById ( &x27;progress-bar&x27; ). style . width = progress + &x27;%&x27; ; }); Adding a Back-to-Top Button Add before the closing </body> tag: < button class = \"back-to-top\" id = \"back-to-top\" aria-label = \"Back to top\" > < svg viewBox = \"0 0 24 24\" width = \"24\" height = \"24\" > < path fill = \"currentColor\" d = \"M12 4l-8 8h5v8h6v-8h5z\" /> </ svg > </ button > Add JavaScript: const backToTop = document . getElementById ( &x27;back-to-top&x27; ); window . addEventListener ( &x27;scroll&x27; , function ( ) { if ( window . scrollY > 300 ) { backToTop. classList . add ( &x27;visible&x27; ); } else { backToTop. classList . remove ( &x27;visible&x27; ); } }); backToTop. addEventListener ( &x27;click&x27; , function ( ) { window . scrollTo ({ top : 0 , behavior : &x27;smooth&x27; }); }); Creating Custom Placeholders To add new placeholders, you need to modify build.js . The placeholder replacement happens in the generatePage function: function generatePage ( processed ) { const template = readTemplate ( &x27;base&x27; ); let html = template . replace ( /\\{\\{siteTitle\\}\\}/g , CONFIG . headerTitle ) . replace ( /\\{\\{title\\}\\}/g , processed. title ) // ... other replacements . replace ( /\\{\\{yourNewPlaceholder\\}\\}/g , yourValue); return html; } Example: Adding a Last Updated Placeholder In templates/base.html , add the placeholder where you want it: < article class = \"article\" > < div class = \"last-updated\" > Last updated: {{lastUpdated}} </ div > {{content}} </ article > In build.js , modify processMarkdownFile to get the file modification date: function processMarkdownFile ( filePath ) { const stats = fs. statSync (filePath); const lastUpdated = stats. mtime . toLocaleDateString ( &x27;en-US&x27; , { year : &x27;numeric&x27; , month : &x27;long&x27; , day : &x27;numeric&x27; }); // ... existing code ... return { // ... existing properties lastUpdated }; } In generatePage , add the replacement: . replace ( /\\{\\{lastUpdated\\}\\}/g , processed. lastUpdated || &x27;&x27; ) Template Best Practices Keep Inline Scripts Minimal The inline scripts in <head> prevent flash of unstyled content (FOUC) for theme and sidebar state. Keep these scripts small and focused. Heavy JavaScript should go in external files loaded at the end of </body> . Maintain Accessibility When modifying the template: Keep semantic HTML structure (header, main, nav, aside, footer) Maintain ARIA labels on interactive elements Ensure keyboard navigation continues to work Test with screen readers if possible Test Thoroughly After template changes: Rebuild the site: npm run build Test multiple pages (homepage, category pages, article pages) Test both themes (dark and light) Test on mobile and desktop Verify all interactive features still work Version Control Your Changes Before making significant template changes, commit your current working state: git add . git commit -m \"Backup before template changes\" This allows you to easily revert if something breaks. Common Template Issues Broken Placeholders If you see {{placeholder}} literally in your output, the placeholder name may be misspelled or missing from the generatePage function in build.js . Missing Styles If styles are missing after template changes, verify: CSS links are correct and paths start with / The static/css folder was copied to dist/css No syntax errors in CSS files JavaScript Not Working If interactive features stop working: Check browser console for errors (press F12) Verify script paths are correct Ensure scripts are loaded in the right order (dependencies first) WARNING Modifying the template can break your site if done incorrectly. Always test thoroughly after making changes, and keep backups of working versions."
  },
  {
    "title": "Themes and Styling",
    "url": "/customization/themes-and-styling",
    "description": "Customize your MarkStack site's colors, typography, spacing, logos, and code highlighting for both dark and light themes.",
    "content": "Themes and Styling MarkStack uses CSS custom properties (also called CSS variables) to control every visual aspect of your site. This guide shows you how to customize colors, typography, spacing, and more for both dark and light themes. Understanding CSS Custom Properties CSS custom properties are variables defined in CSS that you can reuse throughout your stylesheets. MarkStack defines all its design tokens as custom properties in static/css/main.css . Here is how they work: / Define a variable / :root { --color-accent : 22c55e ; } / Use the variable / .button { background-color : var (--color-accent); } When you change --color-accent , every element using that variable updates automatically. This makes theming straightforward and consistent. Theme Structure MarkStack supports dark and light themes. Each theme defines its own set of color values: / Dark theme colors / [data-theme= \"dark\" ] { --color-bg : 0f0f0f ; --color-text : f5f5f5 ; --color-accent : 22c55e ; / ... more colors / } / Light theme colors / [data-theme= \"light\" ] { --color-bg : ffffff ; --color-text : 171717 ; --color-accent : 16a34a ; / ... more colors / } The theme is controlled by the data-theme attribute on the <html> element. Users toggle between themes using the theme button in the header. Color System Core Colors These colors control the fundamental appearance of your site: Variable Purpose Dark Default Light Default --color-bg Page background 0f0f0f ffffff --color-bg-secondary Cards, code blocks 171717 f5f5f5 --color-bg-tertiary Hover states 262626 e5e5e5 --color-text Primary text f5f5f5 171717 --color-text-secondary Muted text a3a3a3 525252 --color-text-tertiary Subtle text 737373 737373 --color-accent Links, highlights 22c55e 16a34a --color-border Borders, dividers 262626 e5e5e5 Changing Your Accent Color The accent color appears on links, the current sidebar item, search highlights, and interactive elements. To change it: Open static/css/main.css Find the [data-theme=\"dark\"] section Change --color-accent to your color Find the [data-theme=\"light\"] section Change --color-accent to a darker version of your color (for contrast on light backgrounds) Example using blue: [data-theme= \"dark\" ] { --color-accent : 3b82f6 ; / Blue for dark theme / } [data-theme= \"light\" ] { --color-accent : 2563eb ; / Darker blue for light theme / } Complete Theme Example Here is a complete color palette swap for a purple theme: [data-theme= \"dark\" ] { --color-bg : 0c0a14 ; --color-bg-secondary : 1a1625 ; --color-bg-tertiary : 2d2640 ; --color-text : f3f0ff ; --color-text-secondary : b4a9d6 ; --color-text-tertiary : 8b7bb8 ; --color-accent : a78bfa ; --color-border : 2d2640 ; } [data-theme= \"light\" ] { --color-bg : faf5ff ; --color-bg-secondary : f3e8ff ; --color-bg-tertiary : e9d5ff ; --color-text : 1e1b2e ; --color-text-secondary : 4c3f6b ; --color-text-tertiary : 6b5b8e ; --color-accent : 7c3aed ; --color-border : e9d5ff ; } Typography Font Families MarkStack uses IBM Plex fonts by default. The fonts are loaded from Google Fonts in templates/base.html . To change fonts: Choose your fonts from Google Fonts or another source Update the font link in templates/base.html : < link href = \"https://fonts.googleapis.com/css2?family=Your+Font:wght@400;500;600;700&display=swap\" rel = \"stylesheet\" > Update the font variables in static/css/main.css : :root { --font-sans : &x27;Your Font&x27; , -apple-system, BlinkMacSystemFont, sans-serif; --font-mono : &x27;Your Mono Font&x27; , &x27;Cascadia Code&x27; , &x27;Fira Code&x27; , monospace; } Font Sizes The font size scale uses relative units for accessibility: Variable Default Purpose --font-size-xs 0.75rem Small labels, badges --font-size-sm 0.875rem Secondary text --font-size-base 1rem Body text --font-size-lg 1.125rem Large body text --font-size-xl 1.25rem Subheadings --font-size-2xl 1.5rem Section headings --font-size-3xl 1.875rem Page titles Example of adjusting the scale for larger text: :root { --font-size-base : 1.0625rem ; / Slightly larger body text / --font-size-lg : 1.1875rem ; --font-size-xl : 1.375rem ; } Line Height and Spacing Variable Default Purpose --line-height-tight 1.25 Headings --line-height-normal 1.5 UI elements --line-height-relaxed 1.75 Body text For more readable body text, increase the relaxed line height: :root { --line-height-relaxed : 1.85 ; } Spacing System MarkStack uses a consistent spacing scale based on 0.25rem (4px) increments: Variable Value Pixels --space-1 0.25rem 4px --space-2 0.5rem 8px --space-3 0.75rem 12px --space-4 1rem 16px --space-5 1.25rem 20px --space-6 1.5rem 24px --space-8 2rem 32px --space-10 2.5rem 40px --space-12 3rem 48px These variables are used throughout the CSS for margins, padding, and gaps. Adjusting them will proportionally scale the entire layout. Layout Dimensions These variables control major layout proportions: Variable Default Purpose --sidebar-width 280px Sidebar navigation width --header-height 60px Top header height --content-max-width 900px Maximum article width Example of a wider reading area: :root { --content-max-width : 1000px ; } Logo Customization Replacing the Logo The logo file is static/svg/logo.svg . To replace it: Create or export your logo as an SVG Optimize the SVG (remove unnecessary metadata, minify) Replace the file at static/svg/logo.svg Requirements for the logo: Format: SVG (vector format for crisp display at any size) Dimensions: 32x32 pixels (viewBox should be 32x32 or proportional) Colors: Use currentColor if you want the logo to match the theme Making the Logo Theme-Aware To have your logo change color with the theme, use currentColor for fills: < svg xmlns = \"http://www.w3.org/2000/svg\" viewBox = \"0 0 32 32\" width = \"32\" height = \"32\" > < path fill = \"currentColor\" d = \"M...\" /> </ svg > The logo will inherit the text color from the header. Adjusting Logo Size If your logo needs different dimensions, edit the logo element in templates/base.html : < img src = \"/svg/logo.svg\" alt = \"Logo\" class = \"logo-icon\" width = \"40\" height = \"40\" > Then adjust the corresponding CSS in static/css/main.css : .logo-icon { width : 40px ; height : 40px ; } Code Syntax Highlighting Code block colors are defined in static/css/hljs-theme.css . This file contains color definitions for syntax highlighting powered by highlight.js. Understanding the Highlight Styles The file defines colors for different code tokens: [data-theme= \"dark\" ] .hljs { --hljs-keyword : ff7b72 ; / Keywords like if, for, function / --hljs-string : a5d6ff ; / String literals / --hljs-number : 79c0ff ; / Numeric values / --hljs-comment : 8b949e ; / Comments / --hljs-function : d2a8ff ; / Function names / --hljs-variable : ffa657 ; / Variables / --hljs-type : 7ee787 ; / Type names / } Customizing Syntax Colors To change syntax highlighting colors: Open static/css/hljs-theme.css Find the theme section (dark or light) Modify the color values Example of a more muted syntax theme: [data-theme= \"dark\" ] .hljs { --hljs-keyword : c792ea ; --hljs-string : c3e88d ; --hljs-number : f78c6c ; --hljs-comment : 546e7a ; --hljs-function : 82aaff ; --hljs-variable : f07178 ; --hljs-type : ffcb6b ; } Code Block Background The code block background is controlled in main.css : pre .hljs { background-color : var (--color-bg-secondary); border : 1px solid var (--color-border); border-radius : var (--radius-md); } Alert Box Colors GitHub-style alerts have their own color scheme. Each alert type has a distinct color: .alert-note { --alert-color : 2563eb ; } .alert-tip { --alert-color : 22c55e ; } .alert-important { --alert-color : a855f7 ; } .alert-warning { --alert-color : eab308 ; } .alert-caution { --alert-color : ef4444 ; } To customize alert colors, find these definitions in main.css and adjust the color values. Sidebar Styling Sidebar Background .sidebar { background-color : var (--color-bg-secondary); border-right : 1px solid var (--color-border); } Active Item Highlight .sidebar-current > a { background-color : var (--color-accent); color : var (--color-bg); } Folder and File Icons The sidebar uses inline SVG icons. To change their appearance: .sidebar-icon { width : 16px ; height : 16px ; fill : var (--color-text-secondary); } Header Styling Header Background .site-header { background-color : var (--color-bg); border-bottom : 1px solid var (--color-border); } Search Box .search-container { background-color : var (--color-bg-secondary); border : 1px solid var (--color-border); border-radius : var (--radius-lg); } Testing Your Changes After making changes: Rebuild the site: npm run build Preview locally: npx serve dist Test both dark and light themes Check on different screen sizes Verify color contrast for accessibility TIP Use the Lighthouse tool in Chrome DevTools to audit accessibility, including color contrast ratios. Common Customization Patterns Brand Color Integration When applying your brand colors, consider the full palette: Primary brand color for accents Darker variant for hover states Lighter variant for backgrounds Ensure sufficient contrast for text Maintaining Readability When changing colors: Text should have at least 4.5:1 contrast ratio with its background Large text (18px+) can use 3:1 contrast ratio Interactive elements need distinct hover and focus states Dark Theme Considerations For dark themes: Avoid pure black ( 000000 ); use dark grays instead Keep text slightly off-white to reduce eye strain Muted colors often work better than vibrant ones"
  },
  {
    "title": "Customization",
    "url": "/customization/",
    "description": "Learn how to customize your MarkStack site's appearance with themes, colors, typography, logos, and template modifications.",
    "content": "Customization MarkStack ships with a clean, professional design that works well for most documentation sites. When you need to match your brand or adjust the design, this section shows you how to customize every visual aspect of your site. Customization Approach MarkStack uses CSS custom properties (CSS variables) for theming. This approach means: No build tools required : Edit CSS files directly, save, and rebuild Consistent changes : Update a color once, it changes everywhere Theme support : Dark and light themes share the same structure, just different values Easy experimentation : Try changes quickly without complex toolchains All customization happens in three locations: File Purpose static/css/main.css Colors, typography, spacing, layout static/css/hljs-theme.css Code syntax highlighting colors templates/base.html Page structure, scripts, meta tags What This Section Covers Themes and Styling The Themes and Styling guide covers visual customization: Changing colors for dark and light themes Adjusting typography (fonts, sizes, weights) Modifying spacing and layout proportions Customizing code block appearance Replacing the logo Making your site match your brand This is the guide for changing how your site looks without modifying the underlying structure. Templates The Templates guide covers structural customization: Understanding the HTML template and placeholders Adding analytics scripts Including additional meta tags Modifying the page layout Extending the build process for new features This is the guide for changing what your site includes or how pages are structured. Common Customization Tasks Here are quick references for the most common customizations: Change the Accent Color Edit static/css/main.css and find the --color-accent variable: [data-theme= \"dark\" ] { --color-accent : 22c55e ; / Change this / } [data-theme= \"light\" ] { --color-accent : 16a34a ; / And this / } Replace the Logo Replace static/svg/logo.svg with your own SVG file. Keep it at 32x32 pixels for best results. Change Fonts Edit the font variables in static/css/main.css : :root { --font-sans : &x27;Your Font&x27; , -apple-system, sans-serif; --font-mono : &x27;Your Mono Font&x27; , monospace; } Add Analytics Edit templates/base.html and add your analytics script before the closing </head> tag. Design Philosophy MarkStackâ€™s default design follows these principles: Readability first : Typography optimized for long-form reading Reduce visual noise : Clean lines, consistent spacing, minimal decoration Accessibility : Color contrasts meet WCAG guidelines, keyboard navigation works Responsive : Works on phones, tablets, and desktops When customizing, consider maintaining these qualities. Test your changes across screen sizes and verify color contrast for accessibility. Before You Customize Before making changes: Build the default site and preview it to understand the baseline Identify specifically what you want to change Make one change at a time and verify it works Keep notes on what you changed for future reference TIP Use your browserâ€™s developer tools to inspect elements and experiment with CSS changes before editing files. Press F12 in most browsers to open developer tools."
  },
  {
    "title": "Installation",
    "url": "/getting-started/installation",
    "description": "Complete guide to installing MarkStack prerequisites, cloning the repository, and verifying your development environment works correctly.",
    "content": "Installation This guide walks through every step needed to get MarkStack running on your machine. Even if you have never used Node.js before, you will have a working installation by the end. Prerequisites Before installing MarkStack, you need two things on your computer: Node.js (version 18 or later) Node.js is a JavaScript runtime that executes the MarkStack build script. MarkStack requires Node.js version 18.0.0 or later because the build script uses modern JavaScript features not available in older versions. To check if Node.js is already installed, open a terminal and run: node --version If you see a version number starting with v18 or higher (like v18.17.0 or v20.10.0 ), you are ready to proceed. If you see â€œcommand not foundâ€ or a version below 18, you need to install or upgrade Node.js. Installing Node.js Download Node.js from the official website: https://nodejs.org Choose the LTS (Long Term Support) version, which is the left button on the download page. LTS versions receive security updates and bug fixes for years, making them the most reliable choice. On Windows: Download the .msi installer, run it, and follow the prompts. The installer adds Node.js to your system PATH automatically. On macOS: Download the .pkg installer, run it, and follow the prompts. Alternatively, if you use Homebrew, run brew install node@20 . On Linux: Use your distributionâ€™s package manager or download from nodejs.org . For Ubuntu/Debian: curl -fsSL https://deb.nodesource.com/setup20.x | sudo -E bash - sudo apt-get install -y nodejs After installing, close and reopen your terminal, then verify the installation: node --version npm --version Both commands should print version numbers. npm (Node Package Manager) comes bundled with Node.js, so installing Node.js gives you npm automatically. Git Git is used to clone the MarkStack repository. Most developers already have Git installed. Check by running: git --version If Git is not installed, download it from https://git-scm.com or install via your systemâ€™s package manager. Step 1: Clone the Repository Open a terminal and navigate to the directory where you want to create your MarkStack project. Then clone the repository: git clone https://github.com/ISIL-AvishayRapp/markstack.git cd markstack This creates a new folder called markstack containing all the source files and changes your working directory into it. NOTE If you want to name your project folder something other than â€œmarkstackâ€, you can specify a different name when cloning: git clone https://github.com/ISIL-AvishayRapp/markstack.git my-docs-site cd my-docs-site Step 2: Install Dependencies MarkStack uses several npm packages for markdown parsing, syntax highlighting, and file watching. Install all dependencies with a single command: npm install This command reads the package.json file, downloads all required packages from the npm registry, and stores them in a nodemodules folder. The process typically takes 10 to 30 seconds depending on your internet connection. You will see output showing packages being downloaded and installed. When it finishes, you should see a summary like: added 147 packages in 12s The exact number of packages may vary between versions. Step 3: Run Your First Build With dependencies installed, you can now generate the site: npm run build This executes the MarkStack build script, which: Scans the content/ directory for markdown files Parses frontmatter and markdown content Generates HTML pages with navigation and search Copies static assets (CSS, JavaScript, images) Writes everything to the dist/ folder A successful build prints output like: ğŸ”¨ Building MarkStack... âœ“ Copied static files âœ“ Generated: /getting-started/ âœ“ Generated: /getting-started/installation/ âœ“ Generated: /getting-started/quickstart/ ... (more pages) âœ“ Generated: / (homepage) âœ“ Generated: /404.html âœ“ Generated: /search-index.json (25 pages) âœ… Build complete in 87ms ğŸ“ Output: /path/to/markstack/dist The build completes in well under a second for most documentation sites. Step 4: Verify the Output After building, your dist/ folder should contain the generated site. You can check its contents: On macOS/Linux ls dist/ On Windows PowerShell Get-ChildItem dist/ You should see: index.html (the homepage) 404.html (the error page) search-index.json (the search data) css/ folder (stylesheets) js/ folder (JavaScript) svg/ folder (icons and logo) One folder for each documentation section Step 5: Preview Locally To view the generated site in your browser, start the preview server: npm run serve This starts a local web server that serves files from dist/ . Open your browser to: http://localhost:3000 You should see the MarkStack documentation site with working navigation, search, and theme toggle. Click around to verify everything works. Press Ctrl+C in the terminal to stop the server when you are done. Troubleshooting npm install hangs or fails If npm install seems stuck or fails with network errors: Check your internet connection If you are behind a corporate proxy, configure npm to use it: npm config set proxy http://your-proxy:port npm config set https-proxy http://your-proxy:port Try clearing the npm cache and reinstalling: npm cache clean --force npm install Permission errors on macOS or Linux If you see EACCES permission errors: Never use sudo with npm. It creates permission problems that are hard to fix. Check that your user owns the project folder: ls -la If needed, fix ownership: sudo chown -R $( whoami ) . Native module build errors If you see errors mentioning gyp , node-gyp , or â€œnative moduleâ€: Make sure you are using Node.js 18 or later Delete the existing modules and lockfile, then reinstall: rm -rf node_modules package-lock.json npm install Windows-specific issues On Windows, prefer running commands from a normal PowerShell or Command Prompt window rather than an elevated (Administrator) shell. Elevated shells can create files with permissions that cause problems later. If you use Windows Subsystem for Linux (WSL), you can follow the Linux instructions instead. Build fails with syntax errors If npm run build fails with JavaScript syntax errors, your Node.js version is likely too old. Verify you have version 18 or later: node --version If not, upgrade Node.js and reinstall dependencies. Next Steps With installation complete, proceed to the Quickstart guide to learn the development workflow for editing and previewing your documentation. TIP Bookmark the project folder location. You will return to it frequently when working on your documentation."
  },
  {
    "title": "Project Structure",
    "url": "/getting-started/project-structure",
    "description": "Complete guide to the MarkStack folder structure, explaining what each directory contains, which files you should edit, and how content transforms into your documentation site.",
    "content": "Project Structure Understanding the MarkStack folder structure helps you work confidently with the project. This guide explains every folder and key file, shows you what you should edit versus what is generated, and describes how files transform from source to output. Directory Overview Here is the complete structure of a MarkStack project with explanations: markstack/ â”œâ”€â”€ build.js The static site generator (single file) â”œâ”€â”€ siteconfig.json Site-wide configuration â”œâ”€â”€ package.json npm scripts and dependencies â”œâ”€â”€ package-lock.json Locked dependency versions â”œâ”€â”€ README.md Project documentation â”œâ”€â”€ LICENSE License file â”‚ â”œâ”€â”€ content/ YOUR CONTENT LIVES HERE â”‚ â”œâ”€â”€ index.md Homepage content (optional) â”‚ â”œâ”€â”€ getting-started/ A category folder â”‚ â”‚ â”œâ”€â”€ index.md Category landing page â”‚ â”‚ â”œâ”€â”€ installation.md â”‚ â”‚ â”œâ”€â”€ quickstart.md â”‚ â”‚ â””â”€â”€ project-structure.md â”‚ â”œâ”€â”€ authoring/ Another category â”‚ â”‚ â”œâ”€â”€ index.md â”‚ â”‚ â”œâ”€â”€ content-model.md â”‚ â”‚ â””â”€â”€ ... more pages â”‚ â””â”€â”€ ... more categories â”‚ â”œâ”€â”€ templates/ â”‚ â””â”€â”€ base.html HTML template with placeholders â”‚ â”œâ”€â”€ static/ Static assets (copied to dist/) â”‚ â”œâ”€â”€ css/ â”‚ â”‚ â”œâ”€â”€ main.css Main stylesheet â”‚ â”‚ â””â”€â”€ hljs-theme.css Code syntax highlighting â”‚ â”œâ”€â”€ js/ â”‚ â”‚ â””â”€â”€ app.js Client-side JavaScript â”‚ â””â”€â”€ svg/ â”‚ â””â”€â”€ logo.svg Site logo â”‚ â”œâ”€â”€ dist/ GENERATED OUTPUT (do not edit) â”‚ â”œâ”€â”€ index.html â”‚ â”œâ”€â”€ 404.html â”‚ â”œâ”€â”€ search-index.json â”‚ â”œâ”€â”€ css/ â”‚ â”œâ”€â”€ js/ â”‚ â”œâ”€â”€ svg/ â”‚ â””â”€â”€ ... generated pages â”‚ â””â”€â”€ nodemodules/ npm packages (do not edit) What You Should Edit These folders and files are your working areas. Changes you make here become your documentation site. content/ This is where all your documentation lives. Every markdown file you create here becomes a page on your site. The folder structure directly determines your siteâ€™s navigation: content/ â”œâ”€â”€ getting-started/ â†’ Sidebar section: \"Getting Started\" â”‚ â”œâ”€â”€ index.md â†’ Category landing page â”‚ â”œâ”€â”€ installation.md â†’ Page: \"Installation\" â”‚ â””â”€â”€ quickstart.md â†’ Page: \"Quickstart\" â””â”€â”€ guides/ â†’ Sidebar section: \"Guides\" â”œâ”€â”€ index.md â†’ Category landing page â””â”€â”€ advanced.md â†’ Page: \"Advanced\" Key files in content: File Purpose index.md Category landing page with title and description *.md Individual documentation pages siteconfig.json Controls site-wide settings like the title, description, and homepage behavior. Edit this file to brand your site: { \"siteTitle\" : \"My Documentation Site\" , \"headerTitle\" : \"MyDocs\" , \"siteSubtitle\" : \"Complete guides and references\" , \"siteUrl\" : \"https://docs.example.com\" , \"defaultDescription\" : \"Official documentation\" , \"showHero\" : true , \"copyrightText\" : \"Â© 2024 Your Company\" } static/ Files here copy directly to dist/ without processing. This is where you put: CSS files for styling ( static/css/ ) JavaScript files for client-side behavior ( static/js/ ) Images for content and branding ( static/images/ or static/svg/ ) Downloadable files like PDFs ( static/files/ ) When you reference these in markdown, use absolute paths: ! Diagram Download PDF templates/base.html The HTML template that wraps every page. It contains placeholders that the build script replaces: Placeholder Replaced With {{title}} Page title from frontmatter {{description}} Page description from frontmatter {{content}} Rendered markdown HTML {{sidebar}} Generated navigation tree {{breadcrumbs}} Generated breadcrumb links {{siteTitle}} Site title from siteconfig.json {{copyrightText}} Copyright from siteconfig.json Edit this file to: Add analytics scripts Include additional meta tags Modify the page layout Add custom header or footer elements What You Should Not Edit These folders are generated or managed automatically. Editing them directly will cause your changes to be lost or create conflicts. dist/ This folder contains the generated website. Every time you run npm run build , the build script: Deletes the previous contents Generates fresh HTML from your content Copies static assets Any manual changes to dist/ disappear on the next build. To change something in dist/ , edit the source files in content/ , static/ , or templates/ instead. IMPORTANT Never edit files in dist/ directly. Your changes will be overwritten on the next build. nodemodules/ Contains npm packages installed by npm install . This folder is managed by npm and excluded from version control. If you need different packages, edit package.json and run npm install , but do not modify nodemodules/ directly. Understanding build.js The build.js file is the complete static site generator in a single file. You generally do not need to modify it for normal documentation work, but understanding what it does helps when troubleshooting: Section Purpose Dependencies Loads required npm packages Markdown configuration Sets up markdown-it with extensions Site configuration Reads siteconfig.json URL mapping Creates title-based URLs from file paths Navigation generation Builds sidebar and breadcrumbs Page rendering Combines content with templates Search indexing Extracts plain text for client search Build process Orchestrates the complete pipeline Advanced users modify build.js to: Add new frontmatter fields Create new template placeholders Implement custom markdown extensions Change URL generation rules How Content Becomes Pages Understanding the transformation from source to output helps you troubleshoot when things do not appear as expected. Step 1: You Create a Markdown File You create content/guides/setup.md : --- title: Initial Setup description: Configure your environment for first use. --- Initial Setup Follow these steps to configure your environment. Step 2: Build Scans and Parses When you run npm run build , the build script: Finds content/guides/setup.md Reads the frontmatter ( title: Initial Setup ) Slugifies the title: â€œInitial Setupâ€ becomes â€œinitial-setupâ€ Records the URL: /initial-setup/ Step 3: Markdown Converts to HTML The markdown content transforms: Headers become <h1> , <h2> , etc. with anchor links Paragraphs become <p> tags Code blocks get syntax highlighting Alerts become styled callout boxes Step 4: Template Applies The rendered HTML injects into base.html : {{title}} becomes â€œInitial Setupâ€ {{description}} becomes â€œConfigure your environmentâ€¦â€ {{content}} becomes the rendered HTML {{sidebar}} becomes the navigation tree {{breadcrumbs}} becomes the breadcrumb links Step 5: Output Writes The complete page writes to: dist/initial-setup/index.html The folder name comes from the slugified title. The index.html filename enables clean URLs where /initial-setup/ loads the page without needing to specify .html . Content Model Summary Understanding the content model helps you organize your documentation effectively. Categories Categories are folders in content/ that group related pages. Each category can have: index.md : A landing page with a title and optional description Multiple .md files: Individual pages within the category Subcategories: Nested folders for further organization content/ â”œâ”€â”€ guides/ Category â”‚ â”œâ”€â”€ index.md Landing: \"Guides\" â”‚ â”œâ”€â”€ quick-start.md Page: \"Quick Start\" â”‚ â””â”€â”€ advanced/ Subcategory â”‚ â”œâ”€â”€ index.md Landing: \"Advanced\" â”‚ â””â”€â”€ plugins.md Page: \"Plugins\" Pages Pages are markdown files that become documentation pages. They have: Frontmatter : YAML at the top with title and description Content : Markdown body rendered as HTML URLs URLs generate from titles, not filenames: Frontmatter Generated URL title: Quick Start /quick-start/ title: API Reference /api-reference/ title: Getting Started /getting-started/ This means you can name your files however you want ( 001-intro.md , first-steps.md ) and the URL will always be based on the human-readable title. Practical Examples Adding a New Category Create a folder: content/tutorials/ Create the landing page: content/tutorials/_index.md --- title: Tutorials description: Step-by-step tutorials for common tasks. --- Tutorials Work through these tutorials to learn by doing. Add a page: content/tutorials/getting-started.md --- title: Getting Started Tutorial description: Your first tutorial to learn the basics. --- Getting Started Tutorial Let&x27;s build something together. Run npm run build The sidebar now shows â€œTutorialsâ€ with â€œGetting Started Tutorialâ€ inside Adding an Image Put the image in static/images/diagram.png Reference it in markdown: ! Architecture diagram Run npm run build The image appears at /images/diagram.png in the output Customizing the Site Logo Replace static/svg/logo.svg with your own SVG Run npm run build Your logo appears in the site header TIP Keep the logo at 32x32 pixels for best results in the header. Larger logos may need CSS adjustments. Next Steps You now understand the MarkStack project structure. Continue to Authoring Content to learn how to write effective documentation with all the markdown features MarkStack supports."
  },
  {
    "title": "Quickstart",
    "url": "/getting-started/quickstart",
    "description": "Learn the MarkStack development workflow with step-by-step instructions for building, watching, and previewing your documentation site locally.",
    "content": "Quickstart This guide teaches you the development workflow you will use every time you work on your MarkStack documentation. By the end, you will know how to build your site, preview it locally, and set up automatic rebuilds that make authoring fast and fluid. Understanding the Build Process When you run a build, MarkStack performs these steps: Reads all markdown files from the content/ folder Parses YAML frontmatter to extract titles and descriptions Converts markdown to HTML with syntax highlighting and GitHub-style features Generates sidebar navigation from the folder structure Creates a search index containing all page content Copies static files (CSS, JavaScript, images) to the output Writes everything to the dist/ folder as static HTML The entire process typically completes in under 100 milliseconds. Running a One-Time Build The simplest way to generate your site is a one-time build: npm run build This command generates the complete site and then exits. You will see output showing each page being generated: ğŸ”¨ Building MarkStack... âœ“ Copied static files âœ“ Generated: /getting-started/ âœ“ Generated: /getting-started/installation/ âœ“ Generated: /getting-started/quickstart/ âœ“ Generated: /getting-started/project-structure/ âœ“ Generated: /authoring/ ... (additional pages) âœ“ Generated: / (homepage) âœ“ Generated: /404.html âœ“ Generated: /search-index.json (28 pages) âœ… Build complete in 92ms ğŸ“ Output: C:\\projects\\markstack\\dist A one-time build is useful for: Verifying your environment works correctly Generating the final site before deployment Troubleshooting when you want a completely fresh build Previewing Your Site Locally After building, you need a web server to view the site properly. Opening the HTML files directly in a browser will not work correctly because the site uses absolute paths for CSS, JavaScript, and links. Start the built-in preview server: npm run serve The server starts and displays the local URL: Serving! Local: http://localhost:3000 Network: http://192.168.1.100:3000 Open http://localhost:3000 in your browser. You should see your documentation site with: The header with site title and search The sidebar navigation showing your content structure The main content area with the current page Working links between pages Functional search (type in the search box or press Ctrl+K) Theme toggle switching between dark and light modes Press Ctrl+C in the terminal to stop the server when you are finished. The Live Authoring Workflow For the best authoring experience, use two terminals: one running watch mode and one running the preview server. This setup automatically rebuilds your site whenever you save a file. Terminal 1: Watch Mode Open a terminal and start watch mode: npm run watch Watch mode does an initial build and then monitors for changes: ğŸ‘€ Watching for changes... ğŸ”¨ Building MarkStack... âœ“ Copied static files ... (build output) âœ… Build complete in 89ms The terminal now waits. Whenever you save a file in content/ , static/ , or templates/ , watch mode detects the change and rebuilds: ğŸ“ Changed: content/getting-started/quickstart.md ğŸ”¨ Building MarkStack... ... (build output) âœ… Build complete in 76ms Leave this terminal running while you work. Terminal 2: Preview Server Open a second terminal and start the preview server: npm run serve Now you have the complete workflow: Edit a markdown file in your text editor Save the file Watch mode detects the change and rebuilds (usually under 100ms) Refresh your browser to see the updated page Setting Up Your Workspace The ideal authoring setup has three windows visible: Window Purpose Text editor Edit markdown files Terminal with watch See rebuild confirmations and any errors Browser Preview the rendered documentation Many developers arrange these side by side or use multiple monitors. VS Code users can use the integrated terminal and live preview extensions. Performing a Clean Build Sometimes you want to start fresh, especially after: Pulling changes from version control Deleting content files (the old generated files might remain) Encountering strange rendering issues To clean and rebuild: npm run clean npm run build The clean command deletes the entire dist/ folder. The subsequent build generates everything from scratch. You can also combine these into a single command: npm run clean && npm run build Verifying Your Setup After completing the quickstart, verify everything works correctly: Check the dist folder Your dist/ folder should contain: dist/ index.html Homepage 404.html Error page search-index.json Search data css/ main.css Styles hljs-theme.css Code highlighting js/ app.js Client-side functionality svg/ logo.svg Site logo getting-started/ Section folder index.html Section landing page installation/ index.html Page quickstart/ index.html project-structure/ index.html ... (more sections) Verify the preview With npm run serve running, check that: The homepage loads without errors (check browser developer console) CSS loads properly (the page should be styled, not plain HTML) JavaScript loads properly (theme toggle and search should work) Sidebar navigation shows your content structure Clicking links navigates to the correct pages Search finds content when you type keywords Test watch mode With npm run watch running: Open any markdown file in content/ Make a small change (add a word to a paragraph) Save the file Check the terminal shows a rebuild completed Refresh the browser and verify the change appears Common Workflows Writing new documentation Start the development environment npm run watch Terminal 1 npm run serve Terminal 2 Create a new markdown file in content/ Edit and save Refresh browser to see results Preparing for deployment Clean build for production npm run clean npm run build Verify locally before deploying npm run serve Check a few pages, then Ctrl+C to stop Deploy the dist/ folder to your host After pulling from Git Update dependencies if package.json changed npm install Clean build to pick up all changes npm run clean npm run build What to Edit First Now that your environment works, here are good first customizations: Site identity (siteconfig.json) Set your siteâ€™s title, subtitle, and other branding: { \"siteTitle\" : \"My Documentation\" , \"headerTitle\" : \"MyDocs\" , \"siteSubtitle\" : \"Everything you need to know\" , \"siteUrl\" : \"https://docs.example.com\" } Homepage content (content/_index.md) Write a welcoming homepage introduction: --- description: Welcome to our documentation portal. --- Welcome Start exploring our documentation using the sidebar navigation. Your first custom page Create a new file in content/ to see the full workflow in action. For example, create content/getting-started/my-first-page.md : --- title: My First Page description: Testing that everything works. --- My First Page This is my first page in MarkStack! Save the file. Watch mode rebuilds. Refresh the browser. Your new page appears in the sidebar. TIP Keep your terminals visible while authoring. When you save a file and nothing happens in the watch terminal, check that you saved to the correct location. When the build succeeds but the browser shows old content, try a hard refresh (Ctrl+Shift+R). Next Steps You now know the MarkStack development workflow. Continue to Project Structure to understand which folders contain your content and which are generated."
  },
  {
    "title": "Getting Started",
    "url": "/getting-started/",
    "description": "Install MarkStack prerequisites, clone the repository, and generate your first documentation site in under five minutes.",
    "content": "Getting Started This section takes you from a fresh start to a fully working MarkStack site running on your local machine. By the end, you will have installed all prerequisites, generated your first build, and have a live preview server showing your documentation. The entire process takes about five minutes if you already have Node.js installed, or about ten minutes if you need to set up Node.js first. What This Section Covers Prerequisites and Installation Before you can use MarkStack, you need Node.js and npm installed on your computer. The Installation guide walks through: Checking if you already have Node.js installed Which Node.js versions work with MarkStack (and which to avoid) How to install Node.js if you need it Cloning the MarkStack repository Installing JavaScript dependencies with npm Running your first build to verify everything works The Development Workflow Once installed, you will use MarkStack in a cycle of editing, building, and previewing. The Quickstart guide shows you: How to run a one-time build that generates your site How to start the preview server to view your documentation locally How to enable watch mode so the site rebuilds automatically as you edit The recommended two-terminal workflow for the fastest authoring experience How to clean the output directory when you need a fresh start Understanding the Project MarkStack uses a specific folder structure where some directories contain your source content and others contain generated output. The Project Structure guide explains: Which folders you should edit (your content lives here) Which folders are generated (do not edit these directly) What each folder contains and its purpose How files in content/ become pages in dist/ Where to put images, CSS, JavaScript, and other assets Recommended Reading Order If you are new to MarkStack, read these guides in order: Installation gets your environment ready and verifies the build works Quickstart teaches the daily workflow of editing and previewing Project Structure gives you the mental map of what goes where After completing this section, you will be ready to move on to Authoring Content where you learn how to write and organize your documentation. System Requirements MarkStack has minimal requirements: Requirement Details Node.js Version 18 or later (LTS releases recommended) npm Comes bundled with Node.js Operating System Windows, macOS, or Linux Disk Space Less than 50 MB for dependencies Text Editor Any editor that handles markdown (VS Code recommended) TIP Use a Node.js LTS (Long Term Support) release like Node 18 or Node 20. These versions receive security updates and bug fixes for years, making them the safest choice for production documentation sites. Time Estimates Task Time Install Node.js (if needed) 5 minutes Clone repository and install dependencies 2 minutes First build and verification 1 minute Learn the development workflow 5 minutes Understand project structure 5 minutes Most users complete the entire Getting Started section in 10 to 15 minutes."
  },
  {
    "title": "Common Issues",
    "url": "/troubleshooting/common-issues",
    "description": "Solutions for common MarkStack problems including build errors, missing pages, styling issues, and deployment failures.",
    "content": "Common Issues This page documents common problems and their solutions. Issues are organized by category for easy reference. Build Errors Cannot find module â€˜Xâ€™ Symptoms: Error: Cannot find module 'markdown-it' Error: Cannot find module 'gray-matter' Error: Cannot find module 'chokidar' Cause: Dependencies are not installed. Solution: npm install If that does not work, try a clean install: rm -rf nodemodules package-lock.json npm install ENOENT: no such file or directory Symptoms: Error: ENOENT: no such file or directory, open 'content/xyz.md' Error: ENOENT: no such file or directory, open 'templates/base.html' Cause: A file or directory that the build script expects is missing. Solution: Verify you are in the correct directory: pwd Should show your MarkStack project folder ls Should show content/, templates/, build.js, etc. If content/ is missing, create it: mkdir content If templates/base.html is missing, you may need to restore it from version control or reinstall MarkStack. SyntaxError in siteconfig.json Symptoms: SyntaxError: Unexpected token } in JSON at position 123 Warning: Could not parse siteconfig.json, using defaults Cause: Invalid JSON syntax in the configuration file. Solution: Open siteconfig.json and check for: Missing commas between properties Trailing commas after the last property Unquoted strings Single quotes instead of double quotes Validate your JSON: node -e \"console.log(JSON.parse(require(&x27;fs&x27;).readFileSync(&x27;siteconfig.json&x27;)))\" Use a JSON validator online or in your editor. Correct format: { \"siteTitle\" : \"My Site\" , \"siteUrl\" : \"https://example.com\" } Common mistakes: { \"siteTitle\" : \"My Site\" , // Trailing comma - WRONG } { siteTitle : \"My Site\" // Unquoted key - WRONG } { \"siteTitle\" : &x27;My Site&x27; // Single quotes - WRONG } Invalid YAML frontmatter Symptoms: YAMLException: bad indentation of a mapping entry YAMLException: can not read a block mapping entry Cause: Syntax error in the YAML frontmatter of a markdown file. Solution: Check the frontmatter uses correct YAML syntax: --- title: My Page Title description: A description of this page --- Common mistakes: Incorrect indentation (use spaces, not tabs) Missing space after the colon Unquoted special characters Quote values with special characters: --- title: \"Getting Started: A Guide\" description: \"Learn about the &x27;features&x27; here\" --- Build hangs or never completes Symptoms: The build starts but never finishes, or takes an extremely long time. Cause: Usually caused by very large files, circular references, or filesystem issues. Solution: Check for very large markdown files (over 1MB) Look for files that should not be in content/ : find content -size +1M Ensure no symbolic links create circular references Try building with fewer files to isolate the problem Missing or Incorrect Pages Page does not appear in navigation Symptoms: A markdown file exists but does not show in the sidebar. Causes and Solutions: File not in content/ directory Verify the file is inside content/ , not at the project root Hidden file Files starting with . are ignored Rename .hidden.md to hidden.md Not a .md file Only .md files are processed Rename .markdown or .txt to .md Build cache issue Run npm run clean && npm run build Page shows wrong title Symptoms: The navigation shows a different title than expected. Cause: MarkStack uses the frontmatter title, falling back to the filename. Solution: Check your frontmatter: --- title: Expected Title Here --- If no frontmatter, the title is derived from the filename: my-page.md becomes â€œMy Pageâ€ MyPage.md becomes â€œMyPageâ€ (no transformation) Page URL is wrong Symptoms: The page is at /my-page/ but you expected /different-url/ . Cause: URLs are generated from titles, not filenames. Solution: The URL comes from the title in frontmatter (slugified) To change the URL, change the title: --- title: Different URL --- This creates /different-url/ 404 for a page that exists Symptoms: Clicking a navigation link shows 404. Causes and Solutions: URL mismatch The link URL does not match the generated URL Check that the page title has not changed Server configuration Your server may not handle clean URLs correctly For nginx, add: tryfiles $uri $uri/ $uri/index.html =404; Case sensitivity Linux servers are case-sensitive /Getting-Started/ is different from /getting-started/ Styling Issues Styles not loading Symptoms: Page appears unstyled, plain HTML. Cause: CSS files are not being served or paths are wrong. Solution: Verify CSS files exist in dist/css/ : ls dist/css/ Should show main.css, hljs-theme.css Check browser network tab for 404 errors on CSS If self-hosting, ensure your server serves static files from dist/ Verify the base path is correct (for subdirectory hosting) Theme toggle does not work Symptoms: Clicking the theme button does nothing. Cause: JavaScript error or missing script. Solution: Check browser console for errors (press F12) Verify app.js exists: ls dist/js/app.js Check for JavaScript errors in the console Ensure no Content Security Policy blocks inline scripts Code blocks not highlighted Symptoms: Code appears but without syntax colors. Cause: Missing language identifier or highlight.js issue. Solution: Specify the language in code blocks: ``javascript const x = 1; `` Check that hljs-theme.css loads: ls dist/css/hljs-theme.css Verify the language is supported by highlight.js Layout broken on mobile Symptoms: Sidebar overlaps content, text too small. Cause: CSS responsive rules not applied or viewport meta missing. Solution: Check that templates/base.html includes the viewport meta: < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > Clear browser cache and reload Check for custom CSS that might override responsive rules Search Issues Search returns no results Symptoms: Searching shows â€œNo results foundâ€ for terms that should match. Causes and Solutions: Search index not generated ls dist/search-index.json File should exist and not be empty Index not loading Check browser network tab for errors loading search-index.json Check browser console for JavaScript errors Query too short Search requires at least 2 characters Try longer search terms Content not indexed Rebuild: npm run build Check that pages have content (not empty) Search is slow Symptoms: Noticeable delay when typing in search. Cause: Large search index or slow device. Solution: Enable gzip compression on your server Consider limiting indexed content length in build.js The search debounces by 150ms; this is normal Ctrl+K shortcut does not work Symptoms: Pressing Ctrl+K does not focus the search box. Cause: Browser or extension intercepting the shortcut. Solution: Some browsers use Ctrl+K for address bar search Some extensions may capture this shortcut Click the search box instead, or press Tab to navigate to it Deployment Issues Site works locally but not deployed Symptoms: Everything works with npx serve dist but fails on the hosting platform. Causes and Solutions: Build not running on host Verify build command is configured: npm run build Check platform build logs for errors Wrong output directory Ensure publish directory is set to dist Not build , public , or out Missing dependencies Ensure package-lock.json is committed Use npm ci instead of npm install in CI Node version mismatch Specify Node version in platform settings Use Node 18 or higher Clean URLs not working Symptoms: /about/ returns 404, but /about/index.html works. Cause: Server not configured for clean URLs. Solution: For Netlify, add netlify.toml : [[redirects]] from = \"/\" to = \"/404.html\" status = 404 For nginx: location / { tryfiles $uri $uri / $uri /index.html = 404 ; } For Apache .htaccess : RewriteEngine On RewriteCond %{REQUESTFILENAME} !-f RewriteCond %{REQUESTFILENAME} /index.html -f RewriteRule ^(.)$ $ 1 /index.html [L] Mixed content warnings Symptoms: Browser shows security warnings, some resources do not load. Cause: Loading HTTP resources on an HTTPS site. Solution: Ensure all resource URLs in templates use https:// or protocol-relative // Check siteconfig.json uses https:// for siteUrl Search generated HTML for http:// and update sources Assets not found after deploy Symptoms: CSS, JS, or images return 404 on production. Cause: Path issues or incomplete deploy. Solution: Verify all files in dist/ were uploaded Check that paths use leading slash: /css/main.css If deployed to subdirectory, update base paths Watch Mode Issues Watch does not detect changes Symptoms: Saving files does not trigger rebuild. Causes and Solutions: Saving to wrong location Verify you are editing files in content/ Editor not saving Check auto-save settings Manually save with Ctrl+S Filesystem events not propagating Some network drives or Docker volumes have issues Try manual build: npm run build Too many files Operating systems limit watched files On Linux, increase limit: echo fs.inotify.maxuserwatches=524288 | sudo tee -a /etc/sysctl.conf Watch uses high CPU Symptoms: npm run watch consumes significant CPU. Cause: Watching too many files or filesystem polling. Solution: Ensure nodemodules is not being watched Close other applications that might compete for filesystem events Use npm run build for one-off builds TIP Most issues can be resolved by reinstalling dependencies ( npm install ) and doing a clean build ( npm run clean && npm run build ). Try this first before investigating further."
  },
  {
    "title": "Frequently Asked Questions",
    "url": "/troubleshooting/frequently-asked-questions",
    "description": "Answers to common questions about MarkStack features, capabilities, limitations, and best practices.",
    "content": "Frequently Asked Questions This page answers common questions about MarkStack. Questions are grouped by topic. General Questions What is MarkStack? MarkStack is a static site generator designed for documentation and knowledge bases. It takes markdown files organized in folders and produces a complete static website with navigation, search, and a professional design. Is MarkStack free? Yes, MarkStack is open source and free to use under the GPL-3.0 license. You can use it for personal projects, commercial documentation, internal wikis, and any other purpose. What makes MarkStack different from other static site generators? MarkStack focuses on simplicity and speed: Single-file build script : No complex toolchain or build pipeline Minimal dependencies : Only essential packages, no framework overhead Fast builds : Typically under 200ms for most sites Convention over configuration : Works out of the box with sensible defaults Modern features : Dark/light themes, search, GitHub-style alerts Who should use MarkStack? MarkStack is ideal for: Technical documentation Knowledge bases and wikis Project documentation Personal notes and references Any content organized hierarchically What are the system requirements? Node.js 18.0.0 or higher Any operating system (Windows, macOS, Linux) Approximately 50MB disk space for dependencies Content Questions What markdown features are supported? MarkStack supports CommonMark markdown plus these extensions: Syntax-highlighted code blocks (190+ languages) GitHub-style task lists Tables Footnotes Auto-linked URLs Heading anchor links GitHub-style alerts (NOTE, TIP, WARNING, etc.) See the Markdown Features page for complete documentation. Can I use HTML in my markdown? Yes, raw HTML is allowed in markdown files. However, use markdown when possible for consistency and maintainability: This is markdown formatting. < div class = \"custom\" > This is < strong > HTML </ strong > formatting. </ div > How do I create a new page? Create a new .md file in the content/ directory: --- title: My New Page description: A description for search and previews --- My New Page Content goes here. Run npm run build to generate the page. How do I create a new category? Create a new folder in content/ with an index.md file: content/ my-category/ index.md Category page first-page.md Page in category second-page.md The index.md file defines the category title and description. Can I nest categories? Yes, you can nest folders as deep as needed: content/ platform/ aws/ ec2/ instances.md volumes.md This creates the URL /platform/aws/ec2/instances/ . How do I control page order in the sidebar? Pages are sorted alphabetically by title. To control order, prefix your titles: --- title: 01 Introduction --- Or use numbered filenames: 01-introduction.md 02-getting-started.md 03-configuration.md Note that numbered filenames affect the URL unless you set a different title in frontmatter. How do I add images? Place images in static/images/ and reference them with absolute paths: ! Alt text Or use external URLs: ! Alt text Can I embed videos? Use HTML to embed videos: < video controls width = \"100%\" > < source src = \"/videos/demo.mp4\" type = \"video/mp4\" > </ video > Or embed from YouTube/Vimeo: < iframe width = \"560\" height = \"315\" src = \"https://www.youtube.com/embed/VIDEOID\" frameborder = \"0\" allowfullscreen > </ iframe > Configuration Questions Where is the configuration file? Site configuration is in siteconfig.json at the project root: { \"siteTitle\" : \"My Knowledge Base\" , \"siteUrl\" : \"https://docs.example.com\" , \"defaultDescription\" : \"Documentation for my project\" } See Site Configuration for all options. How do I change the site title? Edit siteconfig.json : { \"siteTitle\" : \"Your Site Name\" } Rebuild to apply changes. How do I change the logo? Replace static/svg/logo.svg with your own SVG file. Keep it at 32x32 pixels for best results. How do I add custom CSS? Create static/css/custom.css with your styles, then add this to templates/base.html : < link rel = \"stylesheet\" href = \"/css/custom.css\" > Or add styles directly to static/css/main.css . How do I add analytics? Add your analytics script to templates/base.html before the closing </head> tag: < script async src = \"https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX\" > </ script > < script > window . dataLayer = window . dataLayer || []; function gtag ( ){dataLayer. push ( arguments );} gtag ( &x27;js&x27; , new Date ()); gtag ( &x27;config&x27; , &x27;G-XXXXXXXXXX&x27; ); </ script > Building and Deployment How do I build the site? npm run build The generated site is in the dist/ folder. How do I preview locally? npm run build npx serve dist Open http://localhost:3000 in your browser. How do I enable live reload during development? npm run watch This rebuilds automatically when files change. Run npx serve dist in another terminal to view. Note: You still need to manually refresh the browser. Full live reload requires additional setup. Where can I deploy MarkStack sites? Anywhere that serves static files: Recommended : Netlify, Vercel, Cloudflare Pages, GitHub Pages Self-hosted : nginx, Apache, Caddy, any web server Cloud storage : AWS S3, Google Cloud Storage, Azure Blob Storage See Deployment for detailed instructions. Does MarkStack support CI/CD? Yes. Add a build step to your CI pipeline: run: npm ci run: npm run build See CI/CD Integration for GitHub Actions, GitLab CI, and other platforms. Customization Questions How do I change colors? Edit CSS custom properties in static/css/main.css : [data-theme= \"dark\" ] { --color-accent : ff5500 ; / Change accent color / } See Themes and Styling for all customization options. How do I change fonts? Update the font link in templates/base.html Update font variables in static/css/main.css : :root { --font-sans : &x27;Your Font&x27; , sans-serif; } Can I use a different template? MarkStack uses a single template at templates/base.html . You can modify this template to change the page structure. Can I add new markdown extensions? Yes, by modifying build.js . Add markdown-it plugins: const myPlugin = require ( &x27;markdown-it-myplugin&x27; ); md. use (myPlugin); How do I add a new alert type? Add the icon to alertIcons in build.js Add CSS for .alert-yourtype in main.css See the existing alert implementations as examples. Search Questions How does search work? MarkStack generates a JSON index at build time. When users search, JavaScript loads this index and performs client-side text matching. No server required. Can I exclude pages from search? Not in the default build, but you can add this feature by modifying build.js to check for a frontmatter flag: --- title: Hidden Page searchable: false --- Why are my search results not accurate? The search uses substring matching. It finds pages containing the search terms, but does not have fuzzy matching or typo correction. Try: Using more specific terms Checking spelling Using terms that appear exactly in your content How large can the search index get? The index grows with content. Typical sizes: 50 pages: ~100 KB 200 pages: ~400 KB 500 pages: ~1 MB Enable gzip compression on your server to reduce transfer size. Performance Questions How fast are builds? MarkStack builds are fast: 10 pages: ~50ms 50 pages: ~100ms 200 pages: ~300ms 500 pages: ~600ms Can MarkStack handle large sites? Yes, but consider: Build time increases linearly with page count Search index size grows with content For 500+ pages, builds are still under 1 second How do I optimize page load speed? Enable gzip/brotli compression on your server Use a CDN for global distribution Optimize images before adding them Enable HTTP/2 on your server Limitations Does MarkStack support multiple languages (i18n)? Not natively. For multilingual sites, you would need to: Create separate content folders ( content/en/ , content/es/ ) Modify the build script to handle multiple roots Or use separate builds for each language Can I have dynamic content? No. MarkStack generates static HTML. For dynamic features, you would need to add client-side JavaScript or use a different tool. Does MarkStack have a plugin system? Not formally. However, you can extend functionality by: Adding markdown-it plugins Modifying build.js Adding custom JavaScript in static/js/ Can I use MarkStack for a blog? MarkStack is designed for documentation, not blogging. It lacks: Date-based archives RSS feeds Author pages Tags/categories for posts For blogs, consider Hugo, Jekyll, or 11ty. Does MarkStack support comments? Not natively. You can integrate third-party comment systems (Disqus, Giscus, etc.) by adding their scripts to the template."
  },
  {
    "title": "Troubleshooting",
    "url": "/troubleshooting/",
    "description": "Find solutions to common problems, error messages, and frequently asked questions about MarkStack.",
    "content": "Troubleshooting When things do not work as expected, this section helps you diagnose and fix issues. Start with Common Issues for error messages and symptoms, or check the FAQ for general questions. Quick Diagnostics Before diving into specific issues, try these basic checks: Verify Node.js Version node --version MarkStack requires Node.js 18.0.0 or higher. If your version is older, upgrade Node.js. Reinstall Dependencies rm -rf nodemodules npm install On Windows: Remove-Item -Recurse -Force nodemodules npm install Clean Build npm run clean npm run build Check for Syntax Errors If a specific page fails, check the markdown file for: Unclosed code blocks (missing closing ```) Invalid YAML in frontmatter Unmatched brackets or parentheses This Section Covers Common Issues The Common Issues page documents: Build errors and their solutions Missing page problems Styling issues Search not working Deployment problems Each issue includes symptoms, causes, and step-by-step solutions. FAQ The FAQ page answers frequently asked questions: How do I do X? Why does Y happen? Can MarkStack do Z? Getting Help If you cannot find a solution here: Search the documentation : Use Ctrl+K to search for keywords Check GitHub Issues : Someone may have reported the same problem Open a new issue : Provide details about your environment and the problem When reporting issues, include: Node.js version ( node --version ) Operating system Complete error message Steps to reproduce the problem Error Message Quick Reference Error Likely Cause Solution Cannot find module Dependencies not installed Run npm install ENOENT: no such file Missing file or directory Check file paths SyntaxError: Unexpected token Invalid JSON or YAML Check configuration files EACCES: permission denied File permission issue Check folder permissions EADDRINUSE Port already in use Use a different port Debugging Tips Enable Verbose Output Add console.log statements to build.js to trace execution: console . log ( &x27;Processing:&x27; , filePath); console . log ( &x27;URL Map:&x27; , urlMap. get (filePath)); Check Generated Files Inspect files in dist/ to see what was actually generated: List all generated files find dist -name \".html\" | head -20 View a specific file cat dist/getting-started/index.html On Windows: Get-ChildItem dist -Recurse -Filter .html | Select-Object -First 20 Get-Content dist\\getting -started \\index.html Browser Developer Tools Press F12 in your browser to open developer tools: Console : View JavaScript errors Network : Check if resources load Elements : Inspect generated HTML TIP Most issues fall into a few categories: missing dependencies, invalid content syntax, or configuration errors. The solutions are usually simple once you identify the category."
  },
  {
    "title": "MarkStack Documentation",
    "url": "/",
    "description": "Official documentation for MarkStack, a modern static site generator that transforms markdown files into a fast, searchable documentation website with zero configuration.",
    "content": "Welcome to MarkStack MarkStack is a static site generator purpose-built for documentation and knowledge bases. It takes the markdown files you write in a simple folder structure and transforms them into a polished, professional documentation website complete with search, navigation, syntax highlighting, and dark/light themes. This entire documentation site was built using MarkStack itself, so everything you see here demonstrates exactly what the tool can produce. The sidebar navigation, the search bar, the code blocks with copy buttons, the alerts and callouts, and even the theme toggle in the header are all generated from plain markdown files. What Makes MarkStack Different Unlike heavier documentation frameworks that require complex configuration files, plugins, and build pipelines, MarkStack follows a philosophy of simplicity: Single build script : The entire generator is one JavaScript file with no compilation step. You can read it, understand it, and modify it. Folder-based navigation : Your folder structure becomes your sidebar. Create a folder, add markdown files, and navigation appears automatically. Zero configuration to start : Clone the repository, run npm install , and you have a working documentation site. Configuration is optional, not required. Fast builds : Most sites rebuild in under 100 milliseconds, making the write-preview-iterate loop almost instantaneous. Portable output : The generated dist/ folder contains pure static HTML, CSS, and JavaScript. Host it anywhere that serves files: GitHub Pages, Netlify, Vercel, a simple web server, or even a USB drive. How It Works The build process follows a straightforward pipeline: Scan : MarkStack reads every .md file in your content/ directory Parse : Each fileâ€™s frontmatter (the YAML at the top) provides metadata like title and description Transform : Markdown content converts to HTML with syntax highlighting, GitHub-style alerts, task lists, and more Assemble : Navigation trees, breadcrumbs, and search indexes generate automatically from the folder structure Output : Everything writes to dist/ as clean, fast-loading static HTML Documentation Guide This documentation covers everything you need to go from first install to production deployment. Here is the recommended reading path: For New Users Start with the Getting Started section. It walks through prerequisites, installation, and your first build in about five minutes. You will learn the basic workflow and have a running site to experiment with. For Content Authors The Authoring Content section explains how to structure your documentation. Learn about the content model, how frontmatter works, the full range of markdown features supported (including code blocks, alerts, task lists, footnotes, and more), and best practices for organizing large documentation projects. For Site Administrators Configuration covers the siteconfig.json file where you set your site title, description, URLs, and homepage behavior. Customization goes deeper into themes, CSS variables, template modifications, and branding. For DevOps and Deployment Build and Deploy provides the commands reference, CI/CD pipeline examples for GitHub Actions and other platforms, and guides for deploying to popular hosting providers like GitHub Pages, Netlify, Vercel, and Cloudflare Pages. For Contributors and Advanced Users The Architecture section documents how MarkStack works internally. Understand the build pipeline, how navigation and routing decisions are made, and how the search index generates. This knowledge helps if you want to extend or customize the generator itself. When Things Go Wrong Troubleshooting collects solutions to common issues and answers frequently asked questions. Check here before opening an issue if something is not working as expected. Quick Reference Here are the commands you will use most often: Command Purpose npm run build Generate the site once into dist/ npm run watch Rebuild automatically when files change npm run serve Start a local preview server at http://localhost:3000 npm run clean Delete dist/ for a fresh start A typical authoring workflow uses two terminal windows: Terminal 1: Auto-rebuild on changes npm run watch Terminal 2: Preview server npm run serve With this setup, you can edit markdown files, save them, and refresh your browser to see changes immediately. What You Will Find in This Documentation Every section aims to be practical and complete: Step-by-step instructions you can follow without prior knowledge Code samples you can copy and paste directly Examples that mirror real folder structures and configurations Explanations of why things work the way they do, not just how Tips and warnings called out in styled alert boxes TIP As you read through the documentation, keep a terminal running npm run watch in your MarkStack project. Try out concepts as you learn them. The instant rebuild makes experimentation fast and safe. Getting Help If you run into issues not covered in the documentation: Check the Common Issues page for known solutions Review the FAQ for quick answers to frequent questions Search the GitHub repository issues for similar problems Open a new issue with details about your environment and what you tried Welcome to MarkStack. Letâ€™s build something great."
  }
]